// Generated by typings
// Source: node_modules/@angular/compiler/src/version.d.ts
declare module '~@angular/compiler/src/version' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the common package.
 */
import { Version } from '@angular/core';
/**
 * @stable
 */
export const VERSION: Version;
}
declare module '@angular/compiler/src/version' {
export * from '~@angular/compiler/src/version';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/expression_parser/ast.d.ts
declare module '~@angular/compiler/src/expression_parser/ast' {
export class ParserError {
    input: string;
    errLocation: string;
    ctxLocation: any;
    message: string;
    constructor(message: string, input: string, errLocation: string, ctxLocation?: any);
}
export class ParseSpan {
    start: number;
    end: number;
    constructor(start: number, end: number);
}
export class AST {
    span: ParseSpan;
    constructor(span: ParseSpan);
    visit(visitor: AstVisitor, context?: any): any;
    toString(): string;
}
/**
 * Represents a quoted expression of the form:
 *
 * quote = prefix `:` uninterpretedExpression
 * prefix = identifier
 * uninterpretedExpression = arbitrary string
 *
 * A quoted expression is meant to be pre-processed by an AST transformer that
 * converts it into another AST that no longer contains quoted expressions.
 * It is meant to allow third-party developers to extend Angular template
 * expression language. The `uninterpretedExpression` part of the quote is
 * therefore not interpreted by the Angular's own expression parser.
 */
export class Quote extends AST {
    prefix: string;
    uninterpretedExpression: string;
    location: any;
    constructor(span: ParseSpan, prefix: string, uninterpretedExpression: string, location: any);
    visit(visitor: AstVisitor, context?: any): any;
    toString(): string;
}
export class EmptyExpr extends AST {
    visit(visitor: AstVisitor, context?: any): void;
}
export class ImplicitReceiver extends AST {
    visit(visitor: AstVisitor, context?: any): any;
}
/**
 * Multiple expressions separated by a semicolon.
 */
export class Chain extends AST {
    expressions: any[];
    constructor(span: ParseSpan, expressions: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class Conditional extends AST {
    condition: AST;
    trueExp: AST;
    falseExp: AST;
    constructor(span: ParseSpan, condition: AST, trueExp: AST, falseExp: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class PropertyRead extends AST {
    receiver: AST;
    name: string;
    constructor(span: ParseSpan, receiver: AST, name: string);
    visit(visitor: AstVisitor, context?: any): any;
}
export class PropertyWrite extends AST {
    receiver: AST;
    name: string;
    value: AST;
    constructor(span: ParseSpan, receiver: AST, name: string, value: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class SafePropertyRead extends AST {
    receiver: AST;
    name: string;
    constructor(span: ParseSpan, receiver: AST, name: string);
    visit(visitor: AstVisitor, context?: any): any;
}
export class KeyedRead extends AST {
    obj: AST;
    key: AST;
    constructor(span: ParseSpan, obj: AST, key: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class KeyedWrite extends AST {
    obj: AST;
    key: AST;
    value: AST;
    constructor(span: ParseSpan, obj: AST, key: AST, value: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class BindingPipe extends AST {
    exp: AST;
    name: string;
    args: any[];
    constructor(span: ParseSpan, exp: AST, name: string, args: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class LiteralPrimitive extends AST {
    value: any;
    constructor(span: ParseSpan, value: any);
    visit(visitor: AstVisitor, context?: any): any;
}
export class LiteralArray extends AST {
    expressions: any[];
    constructor(span: ParseSpan, expressions: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class LiteralMap extends AST {
    keys: any[];
    values: any[];
    constructor(span: ParseSpan, keys: any[], values: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class Interpolation extends AST {
    strings: any[];
    expressions: any[];
    constructor(span: ParseSpan, strings: any[], expressions: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class Binary extends AST {
    operation: string;
    left: AST;
    right: AST;
    constructor(span: ParseSpan, operation: string, left: AST, right: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class PrefixNot extends AST {
    expression: AST;
    constructor(span: ParseSpan, expression: AST);
    visit(visitor: AstVisitor, context?: any): any;
}
export class MethodCall extends AST {
    receiver: AST;
    name: string;
    args: any[];
    constructor(span: ParseSpan, receiver: AST, name: string, args: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class SafeMethodCall extends AST {
    receiver: AST;
    name: string;
    args: any[];
    constructor(span: ParseSpan, receiver: AST, name: string, args: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class FunctionCall extends AST {
    target: AST;
    args: any[];
    constructor(span: ParseSpan, target: AST, args: any[]);
    visit(visitor: AstVisitor, context?: any): any;
}
export class ASTWithSource extends AST {
    ast: AST;
    source: string;
    location: string;
    errors: ParserError[];
    constructor(ast: AST, source: string, location: string, errors: ParserError[]);
    visit(visitor: AstVisitor, context?: any): any;
    toString(): string;
}
export class TemplateBinding {
    span: ParseSpan;
    key: string;
    keyIsVar: boolean;
    name: string;
    expression: ASTWithSource;
    constructor(span: ParseSpan, key: string, keyIsVar: boolean, name: string, expression: ASTWithSource);
}
export interface AstVisitor {
    visitBinary(ast: Binary, context: any): any;
    visitChain(ast: Chain, context: any): any;
    visitConditional(ast: Conditional, context: any): any;
    visitFunctionCall(ast: FunctionCall, context: any): any;
    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;
    visitInterpolation(ast: Interpolation, context: any): any;
    visitKeyedRead(ast: KeyedRead, context: any): any;
    visitKeyedWrite(ast: KeyedWrite, context: any): any;
    visitLiteralArray(ast: LiteralArray, context: any): any;
    visitLiteralMap(ast: LiteralMap, context: any): any;
    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;
    visitMethodCall(ast: MethodCall, context: any): any;
    visitPipe(ast: BindingPipe, context: any): any;
    visitPrefixNot(ast: PrefixNot, context: any): any;
    visitPropertyRead(ast: PropertyRead, context: any): any;
    visitPropertyWrite(ast: PropertyWrite, context: any): any;
    visitQuote(ast: Quote, context: any): any;
    visitSafeMethodCall(ast: SafeMethodCall, context: any): any;
    visitSafePropertyRead(ast: SafePropertyRead, context: any): any;
}
export class RecursiveAstVisitor implements AstVisitor {
    visitBinary(ast: Binary, context: any): any;
    visitChain(ast: Chain, context: any): any;
    visitConditional(ast: Conditional, context: any): any;
    visitPipe(ast: BindingPipe, context: any): any;
    visitFunctionCall(ast: FunctionCall, context: any): any;
    visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;
    visitInterpolation(ast: Interpolation, context: any): any;
    visitKeyedRead(ast: KeyedRead, context: any): any;
    visitKeyedWrite(ast: KeyedWrite, context: any): any;
    visitLiteralArray(ast: LiteralArray, context: any): any;
    visitLiteralMap(ast: LiteralMap, context: any): any;
    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;
    visitMethodCall(ast: MethodCall, context: any): any;
    visitPrefixNot(ast: PrefixNot, context: any): any;
    visitPropertyRead(ast: PropertyRead, context: any): any;
    visitPropertyWrite(ast: PropertyWrite, context: any): any;
    visitSafePropertyRead(ast: SafePropertyRead, context: any): any;
    visitSafeMethodCall(ast: SafeMethodCall, context: any): any;
    visitAll(asts: AST[], context: any): any;
    visitQuote(ast: Quote, context: any): any;
}
export class AstTransformer implements AstVisitor {
    visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST;
    visitInterpolation(ast: Interpolation, context: any): AST;
    visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST;
    visitPropertyRead(ast: PropertyRead, context: any): AST;
    visitPropertyWrite(ast: PropertyWrite, context: any): AST;
    visitSafePropertyRead(ast: SafePropertyRead, context: any): AST;
    visitMethodCall(ast: MethodCall, context: any): AST;
    visitSafeMethodCall(ast: SafeMethodCall, context: any): AST;
    visitFunctionCall(ast: FunctionCall, context: any): AST;
    visitLiteralArray(ast: LiteralArray, context: any): AST;
    visitLiteralMap(ast: LiteralMap, context: any): AST;
    visitBinary(ast: Binary, context: any): AST;
    visitPrefixNot(ast: PrefixNot, context: any): AST;
    visitConditional(ast: Conditional, context: any): AST;
    visitPipe(ast: BindingPipe, context: any): AST;
    visitKeyedRead(ast: KeyedRead, context: any): AST;
    visitKeyedWrite(ast: KeyedWrite, context: any): AST;
    visitAll(asts: any[]): any[];
    visitChain(ast: Chain, context: any): AST;
    visitQuote(ast: Quote, context: any): AST;
}
}
declare module '@angular/compiler/src/expression_parser/ast' {
export * from '~@angular/compiler/src/expression_parser/ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/private_import_core.d.ts
declare module '~@angular/compiler/src/private_import_core' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { __core_private__ as r } from '@angular/core';
export const isDefaultChangeDetectionStrategy: typeof r.isDefaultChangeDetectionStrategy;
export type ChangeDetectorStatus = typeof r._ChangeDetectorStatus;
export const ChangeDetectorStatus: typeof r.ChangeDetectorStatus;
export type LifecycleHooks = typeof r._LifecycleHooks;
export const LifecycleHooks: typeof r.LifecycleHooks;
export const LIFECYCLE_HOOKS_VALUES: typeof r.LIFECYCLE_HOOKS_VALUES;
export type ReflectorReader = typeof r._ReflectorReader;
export const ReflectorReader: typeof r.ReflectorReader;
export type ViewContainer = typeof r._ViewContainer;
export const ViewContainer: typeof r.ViewContainer;
export const CodegenComponentFactoryResolver: typeof r.CodegenComponentFactoryResolver;
export const ComponentRef_: typeof r.ComponentRef_;
export const AppView: typeof r.AppView;
export const DebugAppView: typeof r.DebugAppView;
export const NgModuleInjector: typeof r.NgModuleInjector;
export const registerModuleFactory: typeof r.registerModuleFactory;
export type ViewType = typeof r._ViewType;
export const ViewType: typeof r.ViewType;
export const view_utils: typeof r.view_utils;
export const DebugContext: typeof r.DebugContext;
export const StaticNodeDebugInfo: typeof r.StaticNodeDebugInfo;
export const devModeEqual: typeof r.devModeEqual;
export const UNINITIALIZED: typeof r.UNINITIALIZED;
export const ValueUnwrapper: typeof r.ValueUnwrapper;
export const TemplateRef_: typeof r.TemplateRef_;
export type RenderDebugInfo = typeof r._RenderDebugInfo;
export const RenderDebugInfo: typeof r.RenderDebugInfo;
export type Console = typeof r._Console;
export const Console: typeof r.Console;
export const reflector: typeof r.reflector;
export const Reflector: typeof r.Reflector;
export type Reflector = typeof r._Reflector;
export type ReflectionCapabilities = typeof r._ReflectionCapabilities;
export const ReflectionCapabilities: typeof r.ReflectionCapabilities;
export type NoOpAnimationPlayer = typeof r._NoOpAnimationPlayer;
export const NoOpAnimationPlayer: typeof r.NoOpAnimationPlayer;
export type AnimationPlayer = typeof r._AnimationPlayer;
export const AnimationPlayer: typeof r.AnimationPlayer;
export type AnimationSequencePlayer = typeof r._AnimationSequencePlayer;
export const AnimationSequencePlayer: typeof r.AnimationSequencePlayer;
export type AnimationGroupPlayer = typeof r._AnimationGroupPlayer;
export const AnimationGroupPlayer: typeof r.AnimationGroupPlayer;
export type AnimationKeyframe = typeof r._AnimationKeyframe;
export const AnimationKeyframe: typeof r.AnimationKeyframe;
export type AnimationStyles = typeof r._AnimationStyles;
export const AnimationStyles: typeof r.AnimationStyles;
export const ANY_STATE: string;
export const DEFAULT_STATE: string;
export const EMPTY_STATE: string;
export const FILL_STYLE_FLAG: string;
export const prepareFinalAnimationStyles: typeof r.prepareFinalAnimationStyles;
export const balanceAnimationKeyframes: typeof r.balanceAnimationKeyframes;
export const clearStyles: typeof r.clearStyles;
export const collectAndResolveStyles: typeof r.collectAndResolveStyles;
export const renderStyles: typeof r.renderStyles;
export type ViewMetadata = typeof r._ViewMetadata;
export const ViewMetadata: typeof r.ViewMetadata;
export type ComponentStillLoadingError = typeof r._ComponentStillLoadingError;
export const ComponentStillLoadingError: typeof r.ComponentStillLoadingError;
export const AnimationTransition: typeof r.AnimationTransition;
export type SetterFn = typeof r._SetterFn;
export type GetterFn = typeof r._GetterFn;
export type MethodFn = typeof r._MethodFn;
}
declare module '@angular/compiler/src/private_import_core' {
export * from '~@angular/compiler/src/private_import_core';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/template_parser/template_ast.d.ts
declare module '~@angular/compiler/src/template_parser/template_ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SecurityContext } from '@angular/core';
import { CompileDirectiveSummary, CompileProviderMetadata, CompileTokenMetadata } from '~@angular/compiler/src/compile_metadata';
import { AST } from '~@angular/compiler/src/expression_parser/ast';
import { ParseSourceSpan } from '~@angular/compiler/src/parse_util';
import { LifecycleHooks } from '~@angular/compiler/src/private_import_core';
/**
 * An Abstract Syntax Tree node representing part of a parsed Angular template.
 */
export interface TemplateAst {
    /**
     * The source span from which this node was parsed.
     */
    sourceSpan: ParseSourceSpan;
    /**
     * Visit this node and possibly transform it.
     */
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A segment of text within the template.
 */
export class TextAst implements TemplateAst {
    value: string;
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, ngContentIndex: number, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A bound expression within the text of a template.
 */
export class BoundTextAst implements TemplateAst {
    value: AST;
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    constructor(value: AST, ngContentIndex: number, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A plain attribute on an element.
 */
export class AttrAst implements TemplateAst {
    name: string;
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(name: string, value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A binding for an element property (e.g. `[property]="expression"`) or an animation trigger (e.g.
 * `[@trigger]="stateExp"`)
 */
export class BoundElementPropertyAst implements TemplateAst {
    name: string;
    type: PropertyBindingType;
    securityContext: SecurityContext;
    needsRuntimeSecurityContext: boolean;
    value: AST;
    unit: string;
    sourceSpan: ParseSourceSpan;
    constructor(name: string, type: PropertyBindingType, securityContext: SecurityContext, needsRuntimeSecurityContext: boolean, value: AST, unit: string, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
    isAnimation: boolean;
}
/**
 * A binding for an element event (e.g. `(event)="handler()"`) or an animation trigger event (e.g.
 * `(@trigger.phase)="callback($event)"`).
 */
export class BoundEventAst implements TemplateAst {
    name: string;
    target: string;
    phase: string;
    handler: AST;
    sourceSpan: ParseSourceSpan;
    static calcFullName(name: string, target: string, phase: string): string;
    constructor(name: string, target: string, phase: string, handler: AST, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
    fullName: string;
    isAnimation: boolean;
}
/**
 * A reference declaration on an element (e.g. `let someName="expression"`).
 */
export class ReferenceAst implements TemplateAst {
    name: string;
    value: CompileTokenMetadata;
    sourceSpan: ParseSourceSpan;
    constructor(name: string, value: CompileTokenMetadata, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A variable declaration on a <template> (e.g. `var-someName="someLocalName"`).
 */
export class VariableAst implements TemplateAst {
    name: string;
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(name: string, value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * An element declaration in a template.
 */
export class ElementAst implements TemplateAst {
    name: string;
    attrs: AttrAst[];
    inputs: BoundElementPropertyAst[];
    outputs: BoundEventAst[];
    references: ReferenceAst[];
    directives: DirectiveAst[];
    providers: ProviderAst[];
    hasViewContainer: boolean;
    children: TemplateAst[];
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    endSourceSpan: ParseSourceSpan;
    constructor(name: string, attrs: AttrAst[], inputs: BoundElementPropertyAst[], outputs: BoundEventAst[], references: ReferenceAst[], directives: DirectiveAst[], providers: ProviderAst[], hasViewContainer: boolean, children: TemplateAst[], ngContentIndex: number, sourceSpan: ParseSourceSpan, endSourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A `<template>` element included in an Angular template.
 */
export class EmbeddedTemplateAst implements TemplateAst {
    attrs: AttrAst[];
    outputs: BoundEventAst[];
    references: ReferenceAst[];
    variables: VariableAst[];
    directives: DirectiveAst[];
    providers: ProviderAst[];
    hasViewContainer: boolean;
    children: TemplateAst[];
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    constructor(attrs: AttrAst[], outputs: BoundEventAst[], references: ReferenceAst[], variables: VariableAst[], directives: DirectiveAst[], providers: ProviderAst[], hasViewContainer: boolean, children: TemplateAst[], ngContentIndex: number, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A directive property with a bound value (e.g. `*ngIf="condition").
 */
export class BoundDirectivePropertyAst implements TemplateAst {
    directiveName: string;
    templateName: string;
    value: AST;
    sourceSpan: ParseSourceSpan;
    constructor(directiveName: string, templateName: string, value: AST, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A directive declared on an element.
 */
export class DirectiveAst implements TemplateAst {
    directive: CompileDirectiveSummary;
    inputs: BoundDirectivePropertyAst[];
    hostProperties: BoundElementPropertyAst[];
    hostEvents: BoundEventAst[];
    sourceSpan: ParseSourceSpan;
    constructor(directive: CompileDirectiveSummary, inputs: BoundDirectivePropertyAst[], hostProperties: BoundElementPropertyAst[], hostEvents: BoundEventAst[], sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * A provider declared on an element
 */
export class ProviderAst implements TemplateAst {
    token: CompileTokenMetadata;
    multiProvider: boolean;
    eager: boolean;
    providers: CompileProviderMetadata[];
    providerType: ProviderAstType;
    lifecycleHooks: LifecycleHooks[];
    sourceSpan: ParseSourceSpan;
    constructor(token: CompileTokenMetadata, multiProvider: boolean, eager: boolean, providers: CompileProviderMetadata[], providerType: ProviderAstType, lifecycleHooks: LifecycleHooks[], sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
export enum ProviderAstType {
    PublicService = 0,
    PrivateService = 1,
    Component = 2,
    Directive = 3,
    Builtin = 4,
}
/**
 * Position where content is to be projected (instance of `<ng-content>` in a template).
 */
export class NgContentAst implements TemplateAst {
    index: number;
    ngContentIndex: number;
    sourceSpan: ParseSourceSpan;
    constructor(index: number, ngContentIndex: number, sourceSpan: ParseSourceSpan);
    visit(visitor: TemplateAstVisitor, context: any): any;
}
/**
 * Enumeration of types of property bindings.
 */
export enum PropertyBindingType {
    /**
     * A normal binding to a property (e.g. `[property]="expression"`).
     */
    Property = 0,
    /**
     * A binding to an element attribute (e.g. `[attr.name]="expression"`).
     */
    Attribute = 1,
    /**
     * A binding to a CSS class (e.g. `[class.name]="condition"`).
     */
    Class = 2,
    /**
     * A binding to a style rule (e.g. `[style.rule]="expression"`).
     */
    Style = 3,
    /**
     * A binding to an animation reference (e.g. `[animate.key]="expression"`).
     */
    Animation = 4,
}
/**
 * A visitor for {@link TemplateAst} trees that will process each node.
 */
export interface TemplateAstVisitor {
    visit?(ast: TemplateAst, context: any): any;
    visitNgContent(ast: NgContentAst, context: any): any;
    visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any;
    visitElement(ast: ElementAst, context: any): any;
    visitReference(ast: ReferenceAst, context: any): any;
    visitVariable(ast: VariableAst, context: any): any;
    visitEvent(ast: BoundEventAst, context: any): any;
    visitElementProperty(ast: BoundElementPropertyAst, context: any): any;
    visitAttr(ast: AttrAst, context: any): any;
    visitBoundText(ast: BoundTextAst, context: any): any;
    visitText(ast: TextAst, context: any): any;
    visitDirective(ast: DirectiveAst, context: any): any;
    visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any;
}
/**
 * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.
 */
export function templateVisitAll(visitor: TemplateAstVisitor, asts: TemplateAst[], context?: any): any[];
}
declare module '@angular/compiler/src/template_parser/template_ast' {
export * from '~@angular/compiler/src/template_parser/template_ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/i18n_html_parser.d.ts
declare module '~@angular/compiler/src/i18n/i18n_html_parser' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HtmlParser } from '~@angular/compiler/src/ml_parser/html_parser';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { ParseTreeResult } from '~@angular/compiler/src/ml_parser/parser';
export class I18NHtmlParser implements HtmlParser {
    private _htmlParser;
    private _translations;
    private _translationsFormat;
    getTagDefinition: any;
    constructor(_htmlParser: HtmlParser, _translations?: string, _translationsFormat?: string);
    parse(source: string, url: string, parseExpansionForms?: boolean, interpolationConfig?: InterpolationConfig): ParseTreeResult;
    private _createSerializer();
}
}
declare module '@angular/compiler/src/i18n/i18n_html_parser' {
export * from '~@angular/compiler/src/i18n/i18n_html_parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/template_parser/template_parser.d.ts
declare module '~@angular/compiler/src/template_parser/template_parser' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { OpaqueToken, SchemaMetadata } from '@angular/core';
import { CompileDirectiveMetadata, CompileDirectiveSummary, CompilePipeSummary, CompileTypeMetadata } from '~@angular/compiler/src/compile_metadata';
import { Parser } from '~@angular/compiler/src/expression_parser/parser';
import { I18NHtmlParser } from '~@angular/compiler/src/i18n/i18n_html_parser';
import { ParseTreeResult } from '~@angular/compiler/src/ml_parser/html_parser';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { ParseError, ParseErrorLevel, ParseSourceSpan } from '~@angular/compiler/src/parse_util';
import { Console } from '~@angular/compiler/src/private_import_core';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
import { CssSelector } from '~@angular/compiler/src/selector';
import { TemplateAst, TemplateAstVisitor } from '~@angular/compiler/src/template_parser/template_ast';
/**
 * Provides an array of {@link TemplateAstVisitor}s which will be used to transform
 * parsed templates before compilation is invoked, allowing custom expression syntax
 * and other advanced transformations.
 *
 * This is currently an internal-only feature and not meant for general use.
 */
export const TEMPLATE_TRANSFORMS: OpaqueToken;
export class TemplateParseError extends ParseError {
    constructor(message: string, span: ParseSourceSpan, level: ParseErrorLevel);
}
export class TemplateParseResult {
    templateAst: TemplateAst[];
    errors: ParseError[];
    constructor(templateAst?: TemplateAst[], errors?: ParseError[]);
}
export class TemplateParser {
    private _exprParser;
    private _schemaRegistry;
    private _htmlParser;
    private _console;
    transforms: TemplateAstVisitor[];
    constructor(_exprParser: Parser, _schemaRegistry: ElementSchemaRegistry, _htmlParser: I18NHtmlParser, _console: Console, transforms: TemplateAstVisitor[]);
    parse(component: CompileDirectiveMetadata, template: string, directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[], templateUrl: string): TemplateAst[];
    tryParse(component: CompileDirectiveMetadata, template: string, directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[], templateUrl: string): TemplateParseResult;
    tryParseHtml(htmlAstWithErrors: ParseTreeResult, component: CompileDirectiveMetadata, template: string, directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[], templateUrl: string): TemplateParseResult;
    expandHtml(htmlAstWithErrors: ParseTreeResult, forced?: boolean): ParseTreeResult;
    getInterpolationConfig(component: CompileDirectiveMetadata): InterpolationConfig;
}
export function splitClasses(classAttrValue: string): string[];
export function createElementCssSelector(elementName: string, attributes: [string, string][]): CssSelector;
export function removeSummaryDuplicates<T extends {
    type: CompileTypeMetadata;
}>(items: T[]): T[];
}
declare module '@angular/compiler/src/template_parser/template_parser' {
export * from '~@angular/compiler/src/template_parser/template_parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/config.d.ts
declare module '~@angular/compiler/src/config' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ViewEncapsulation } from '@angular/core';
import { CompileIdentifierMetadata } from '~@angular/compiler/src/compile_metadata';
export class CompilerConfig {
    renderTypes: RenderTypes;
    defaultEncapsulation: ViewEncapsulation;
    private _genDebugInfo;
    private _logBindingUpdate;
    useJit: boolean;
    constructor({renderTypes, defaultEncapsulation, genDebugInfo, logBindingUpdate, useJit}?: {
        renderTypes?: RenderTypes;
        defaultEncapsulation?: ViewEncapsulation;
        genDebugInfo?: boolean;
        logBindingUpdate?: boolean;
        useJit?: boolean;
    });
    genDebugInfo: boolean;
    logBindingUpdate: boolean;
}
/**
 * Types used for the renderer.
 * Can be replaced to specialize the generated output to a specific renderer
 * to help tree shaking.
 */
export abstract class RenderTypes {
    renderer: CompileIdentifierMetadata;
    renderText: CompileIdentifierMetadata;
    renderElement: CompileIdentifierMetadata;
    renderComment: CompileIdentifierMetadata;
    renderNode: CompileIdentifierMetadata;
    renderEvent: CompileIdentifierMetadata;
}
export class DefaultRenderTypes implements RenderTypes {
    renderer: CompileIdentifierMetadata;
    renderText: any;
    renderElement: any;
    renderComment: any;
    renderNode: any;
    renderEvent: any;
}
}
declare module '@angular/compiler/src/config' {
export * from '~@angular/compiler/src/config';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/compile_metadata.d.ts
declare module '~@angular/compiler/src/compile_metadata' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy, SchemaMetadata, Type, ViewEncapsulation } from '@angular/core';
import { LifecycleHooks } from '~@angular/compiler/src/private_import_core';
export class CompileAnimationEntryMetadata {
    name: string;
    definitions: CompileAnimationStateMetadata[];
    constructor(name?: string, definitions?: CompileAnimationStateMetadata[]);
}
export abstract class CompileAnimationStateMetadata {
}
export class CompileAnimationStateDeclarationMetadata extends CompileAnimationStateMetadata {
    stateNameExpr: string;
    styles: CompileAnimationStyleMetadata;
    constructor(stateNameExpr: string, styles: CompileAnimationStyleMetadata);
}
export class CompileAnimationStateTransitionMetadata extends CompileAnimationStateMetadata {
    stateChangeExpr: string;
    steps: CompileAnimationMetadata;
    constructor(stateChangeExpr: string, steps: CompileAnimationMetadata);
}
export abstract class CompileAnimationMetadata {
}
export class CompileAnimationKeyframesSequenceMetadata extends CompileAnimationMetadata {
    steps: CompileAnimationStyleMetadata[];
    constructor(steps?: CompileAnimationStyleMetadata[]);
}
export class CompileAnimationStyleMetadata extends CompileAnimationMetadata {
    offset: number;
    styles: Array<string | {
        [key: string]: string | number;
    }>;
    constructor(offset: number, styles?: Array<string | {
        [key: string]: string | number;
    }>);
}
export class CompileAnimationAnimateMetadata extends CompileAnimationMetadata {
    timings: string | number;
    styles: CompileAnimationStyleMetadata | CompileAnimationKeyframesSequenceMetadata;
    constructor(timings?: string | number, styles?: CompileAnimationStyleMetadata | CompileAnimationKeyframesSequenceMetadata);
}
export abstract class CompileAnimationWithStepsMetadata extends CompileAnimationMetadata {
    steps: CompileAnimationMetadata[];
    constructor(steps?: CompileAnimationMetadata[]);
}
export class CompileAnimationSequenceMetadata extends CompileAnimationWithStepsMetadata {
    constructor(steps?: CompileAnimationMetadata[]);
}
export class CompileAnimationGroupMetadata extends CompileAnimationWithStepsMetadata {
    constructor(steps?: CompileAnimationMetadata[]);
}
export function identifierName(compileIdentifier: CompileIdentifierMetadata): string;
export function identifierModuleUrl(compileIdentifier: CompileIdentifierMetadata): string;
export interface CompileIdentifierMetadata {
    reference: any;
}
export enum CompileSummaryKind {
    Pipe = 0,
    Directive = 1,
    NgModule = 2,
    Injectable = 3,
}
/**
 * A CompileSummary is the data needed to use a directive / pipe / module
 * in other modules / components. However, this data is not enough to compile
 * the directive / module itself.
 */
export interface CompileTypeSummary {
    summaryKind: CompileSummaryKind;
    type: CompileTypeMetadata;
}
export interface CompileDiDependencyMetadata {
    isAttribute?: boolean;
    isSelf?: boolean;
    isHost?: boolean;
    isSkipSelf?: boolean;
    isOptional?: boolean;
    isValue?: boolean;
    token?: CompileTokenMetadata;
    value?: any;
}
export interface CompileProviderMetadata {
    token: CompileTokenMetadata;
    useClass?: CompileTypeMetadata;
    useValue?: any;
    useExisting?: CompileTokenMetadata;
    useFactory?: CompileFactoryMetadata;
    deps?: CompileDiDependencyMetadata[];
    multi?: boolean;
}
export interface CompileFactoryMetadata extends CompileIdentifierMetadata {
    diDeps: CompileDiDependencyMetadata[];
    reference: any;
}
export function tokenName(token: CompileTokenMetadata): string;
export function tokenReference(token: CompileTokenMetadata): any;
export interface CompileTokenMetadata {
    value?: any;
    identifier?: CompileIdentifierMetadata | CompileTypeMetadata;
}
/**
 * Metadata regarding compilation of a type.
 */
export interface CompileTypeMetadata extends CompileIdentifierMetadata {
    diDeps: CompileDiDependencyMetadata[];
    lifecycleHooks: LifecycleHooks[];
    reference: any;
}
export interface CompileQueryMetadata {
    selectors: Array<CompileTokenMetadata>;
    descendants: boolean;
    first: boolean;
    propertyName: string;
    read: CompileTokenMetadata;
}
/**
 * Metadata about a stylesheet
 */
export class CompileStylesheetMetadata {
    moduleUrl: string;
    styles: string[];
    styleUrls: string[];
    constructor({moduleUrl, styles, styleUrls}?: {
        moduleUrl?: string;
        styles?: string[];
        styleUrls?: string[];
    });
}
/**
 * Summary Metadata regarding compilation of a template.
 */
export interface CompileTemplateSummary {
    animations: string[];
    ngContentSelectors: string[];
    encapsulation: ViewEncapsulation;
}
/**
 * Metadata regarding compilation of a template.
 */
export class CompileTemplateMetadata {
    encapsulation: ViewEncapsulation;
    template: string;
    templateUrl: string;
    styles: string[];
    styleUrls: string[];
    externalStylesheets: CompileStylesheetMetadata[];
    animations: CompileAnimationEntryMetadata[];
    ngContentSelectors: string[];
    interpolation: [string, string];
    constructor({encapsulation, template, templateUrl, styles, styleUrls, externalStylesheets, animations, ngContentSelectors, interpolation}?: {
        encapsulation?: ViewEncapsulation;
        template?: string;
        templateUrl?: string;
        styles?: string[];
        styleUrls?: string[];
        externalStylesheets?: CompileStylesheetMetadata[];
        ngContentSelectors?: string[];
        animations?: CompileAnimationEntryMetadata[];
        interpolation?: [string, string];
    });
    toSummary(): CompileTemplateSummary;
}
export interface CompileDirectiveSummary extends CompileTypeSummary {
    type: CompileTypeMetadata;
    isComponent: boolean;
    selector: string;
    exportAs: string;
    inputs: {
        [key: string]: string;
    };
    outputs: {
        [key: string]: string;
    };
    hostListeners: {
        [key: string]: string;
    };
    hostProperties: {
        [key: string]: string;
    };
    hostAttributes: {
        [key: string]: string;
    };
    providers: CompileProviderMetadata[];
    viewProviders: CompileProviderMetadata[];
    queries: CompileQueryMetadata[];
    entryComponents: CompileIdentifierMetadata[];
    changeDetection: ChangeDetectionStrategy;
    template: CompileTemplateSummary;
}
/**
 * Metadata regarding compilation of a directive.
 */
export class CompileDirectiveMetadata {
    static create({isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, host, providers, viewProviders, queries, viewQueries, entryComponents, template}?: {
        isHost?: boolean;
        type?: CompileTypeMetadata;
        isComponent?: boolean;
        selector?: string;
        exportAs?: string;
        changeDetection?: ChangeDetectionStrategy;
        inputs?: string[];
        outputs?: string[];
        host?: {
            [key: string]: string;
        };
        providers?: CompileProviderMetadata[];
        viewProviders?: CompileProviderMetadata[];
        queries?: CompileQueryMetadata[];
        viewQueries?: CompileQueryMetadata[];
        entryComponents?: CompileIdentifierMetadata[];
        template?: CompileTemplateMetadata;
    }): CompileDirectiveMetadata;
    isHost: boolean;
    type: CompileTypeMetadata;
    isComponent: boolean;
    selector: string;
    exportAs: string;
    changeDetection: ChangeDetectionStrategy;
    inputs: {
        [key: string]: string;
    };
    outputs: {
        [key: string]: string;
    };
    hostListeners: {
        [key: string]: string;
    };
    hostProperties: {
        [key: string]: string;
    };
    hostAttributes: {
        [key: string]: string;
    };
    providers: CompileProviderMetadata[];
    viewProviders: CompileProviderMetadata[];
    queries: CompileQueryMetadata[];
    viewQueries: CompileQueryMetadata[];
    entryComponents: CompileIdentifierMetadata[];
    template: CompileTemplateMetadata;
    constructor({isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, hostListeners, hostProperties, hostAttributes, providers, viewProviders, queries, viewQueries, entryComponents, template}?: {
        isHost?: boolean;
        type?: CompileTypeMetadata;
        isComponent?: boolean;
        selector?: string;
        exportAs?: string;
        changeDetection?: ChangeDetectionStrategy;
        inputs?: {
            [key: string]: string;
        };
        outputs?: {
            [key: string]: string;
        };
        hostListeners?: {
            [key: string]: string;
        };
        hostProperties?: {
            [key: string]: string;
        };
        hostAttributes?: {
            [key: string]: string;
        };
        providers?: CompileProviderMetadata[];
        viewProviders?: CompileProviderMetadata[];
        queries?: CompileQueryMetadata[];
        viewQueries?: CompileQueryMetadata[];
        entryComponents?: CompileIdentifierMetadata[];
        template?: CompileTemplateMetadata;
    });
    toSummary(): CompileDirectiveSummary;
}
/**
 * Construct {@link CompileDirectiveMetadata} from {@link ComponentTypeMetadata} and a selector.
 */
export function createHostComponentMeta(typeReference: any, compMeta: CompileDirectiveMetadata): CompileDirectiveMetadata;
export interface CompilePipeSummary extends CompileTypeSummary {
    type: CompileTypeMetadata;
    name: string;
    pure: boolean;
}
export class CompilePipeMetadata {
    type: CompileTypeMetadata;
    name: string;
    pure: boolean;
    constructor({type, name, pure}?: {
        type?: CompileTypeMetadata;
        name?: string;
        pure?: boolean;
    });
    toSummary(): CompilePipeSummary;
}
export interface CompileNgModuleSummary extends CompileTypeSummary {
    type: CompileTypeMetadata;
    exportedDirectives: CompileIdentifierMetadata[];
    exportedPipes: CompileIdentifierMetadata[];
    entryComponents: CompileIdentifierMetadata[];
    providers: {
        provider: CompileProviderMetadata;
        module: CompileIdentifierMetadata;
    }[];
    modules: CompileTypeMetadata[];
}
/**
 * Metadata regarding compilation of a module.
 */
export class CompileNgModuleMetadata {
    type: CompileTypeMetadata;
    declaredDirectives: CompileIdentifierMetadata[];
    exportedDirectives: CompileIdentifierMetadata[];
    declaredPipes: CompileIdentifierMetadata[];
    exportedPipes: CompileIdentifierMetadata[];
    entryComponents: CompileIdentifierMetadata[];
    bootstrapComponents: CompileIdentifierMetadata[];
    providers: CompileProviderMetadata[];
    importedModules: CompileNgModuleSummary[];
    exportedModules: CompileNgModuleSummary[];
    schemas: SchemaMetadata[];
    id: string;
    transitiveModule: TransitiveCompileNgModuleMetadata;
    constructor({type, providers, declaredDirectives, exportedDirectives, declaredPipes, exportedPipes, entryComponents, bootstrapComponents, importedModules, exportedModules, schemas, transitiveModule, id}?: {
        type?: CompileTypeMetadata;
        providers?: CompileProviderMetadata[];
        declaredDirectives?: CompileIdentifierMetadata[];
        exportedDirectives?: CompileIdentifierMetadata[];
        declaredPipes?: CompileIdentifierMetadata[];
        exportedPipes?: CompileIdentifierMetadata[];
        entryComponents?: CompileIdentifierMetadata[];
        bootstrapComponents?: CompileIdentifierMetadata[];
        importedModules?: CompileNgModuleSummary[];
        exportedModules?: CompileNgModuleSummary[];
        transitiveModule?: TransitiveCompileNgModuleMetadata;
        schemas?: SchemaMetadata[];
        id?: string;
    });
    toSummary(): CompileNgModuleSummary;
}
export class TransitiveCompileNgModuleMetadata {
    directivesSet: Set<any>;
    directives: CompileIdentifierMetadata[];
    exportedDirectivesSet: Set<any>;
    exportedDirectives: CompileIdentifierMetadata[];
    pipesSet: Set<any>;
    pipes: CompileIdentifierMetadata[];
    exportedPipesSet: Set<any>;
    exportedPipes: CompileIdentifierMetadata[];
    modulesSet: Set<any>;
    modules: CompileTypeMetadata[];
    entryComponentsSet: Set<any>;
    entryComponents: CompileIdentifierMetadata[];
    providers: {
        provider: CompileProviderMetadata;
        module: CompileIdentifierMetadata;
    }[];
    addProvider(provider: CompileProviderMetadata, module: CompileIdentifierMetadata): void;
    addDirective(id: CompileIdentifierMetadata): void;
    addExportedDirective(id: CompileIdentifierMetadata): void;
    addPipe(id: CompileIdentifierMetadata): void;
    addExportedPipe(id: CompileIdentifierMetadata): void;
    addModule(id: CompileTypeMetadata): void;
    addEntryComponent(id: CompileIdentifierMetadata): void;
}
export class ProviderMeta {
    token: any;
    useClass: Type<any>;
    useValue: any;
    useExisting: any;
    useFactory: Function;
    dependencies: Object[];
    multi: boolean;
    constructor(token: any, {useClass, useValue, useExisting, useFactory, deps, multi}: {
        useClass?: Type<any>;
        useValue?: any;
        useExisting?: any;
        useFactory?: Function;
        deps?: Object[];
        multi?: boolean;
    });
}
}
declare module '@angular/compiler/src/compile_metadata' {
export * from '~@angular/compiler/src/compile_metadata';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/compiler_options.d.ts
declare module '~@angular/compiler/src/aot/compiler_options' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export interface AotCompilerOptions {
    debug?: boolean;
    locale?: string;
    i18nFormat?: string;
    translations?: string;
}
}
declare module '@angular/compiler/src/aot/compiler_options' {
export * from '~@angular/compiler/src/aot/compiler_options';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/compiler_factory.d.ts
declare module '~@angular/compiler/src/aot/compiler_factory' {
import { AotCompiler } from '~@angular/compiler/src/aot/compiler';
import { AotCompilerHost } from '~@angular/compiler/src/aot/compiler_host';
import { AotCompilerOptions } from '~@angular/compiler/src/aot/compiler_options';
import { StaticReflector } from '~@angular/compiler/src/aot/static_reflector';
/**
 * Creates a new AotCompiler based on options and a host.
 */
export function createAotCompiler(compilerHost: AotCompilerHost, options: AotCompilerOptions): {
    compiler: AotCompiler;
    reflector: StaticReflector;
};
}
declare module '@angular/compiler/src/aot/compiler_factory' {
export * from '~@angular/compiler/src/aot/compiler_factory';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/output/abstract_emitter.d.ts
declare module '~@angular/compiler/src/output/abstract_emitter' {
import * as o from '~@angular/compiler/src/output/output_ast';
export const CATCH_ERROR_VAR: o.ReadVarExpr;
export const CATCH_STACK_VAR: o.ReadVarExpr;
export abstract class OutputEmitter {
    abstract emitStatements(moduleUrl: string, stmts: o.Statement[], exportedVars: string[]): string;
}
export class EmitterVisitorContext {
    private _exportedVars;
    private _indent;
    static createRoot(exportedVars: string[]): EmitterVisitorContext;
    private _lines;
    private _classes;
    constructor(_exportedVars: string[], _indent: number);
    private _currentLine;
    isExportedVar(varName: string): boolean;
    println(lastPart?: string): void;
    lineIsEmpty(): boolean;
    print(part: string, newLine?: boolean): void;
    removeEmptyLastLine(): void;
    incIndent(): void;
    decIndent(): void;
    pushClass(clazz: o.ClassStmt): void;
    popClass(): o.ClassStmt;
    currentClass: o.ClassStmt;
    toSource(): any;
}
export abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {
    private _escapeDollarInStrings;
    constructor(_escapeDollarInStrings: boolean);
    visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any;
    visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any;
    abstract visitCastExpr(ast: o.CastExpr, context: any): any;
    abstract visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any;
    visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any;
    abstract visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any;
    visitThrowStmt(stmt: o.ThrowStmt, ctx: EmitterVisitorContext): any;
    visitCommentStmt(stmt: o.CommentStmt, ctx: EmitterVisitorContext): any;
    abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;
    visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any;
    visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any;
    visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any;
    visitInvokeMethodExpr(expr: o.InvokeMethodExpr, ctx: EmitterVisitorContext): any;
    abstract getBuiltinMethodName(method: o.BuiltinMethod): string;
    visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any;
    visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any;
    visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any;
    visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any;
    abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;
    visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any;
    visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any;
    abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;
    abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;
    visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any;
    visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any;
    visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any;
    visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any;
    visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any;
    visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string, newLine?: boolean): void;
    visitAllObjects<T>(handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext, separator: string, newLine?: boolean): void;
    visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void;
}
export function escapeIdentifier(input: string, escapeDollar: boolean, alwaysQuote?: boolean): any;
}
declare module '@angular/compiler/src/output/abstract_emitter' {
export * from '~@angular/compiler/src/output/abstract_emitter';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/generated_file.d.ts
declare module '~@angular/compiler/src/aot/generated_file' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export class GeneratedFile {
    srcFileUrl: string;
    genFileUrl: string;
    source: string;
    constructor(srcFileUrl: string, genFileUrl: string, source: string);
}
}
declare module '@angular/compiler/src/aot/generated_file' {
export * from '~@angular/compiler/src/aot/generated_file';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/compiler.d.ts
declare module '~@angular/compiler/src/aot/compiler' {
import { AnimationParser } from '~@angular/compiler/src/animation/animation_parser';
import { CompileNgModuleMetadata } from '~@angular/compiler/src/compile_metadata';
import { DirectiveWrapperCompiler } from '~@angular/compiler/src/directive_wrapper_compiler';
import { CompileMetadataResolver } from '~@angular/compiler/src/metadata_resolver';
import { NgModuleCompiler } from '~@angular/compiler/src/ng_module_compiler';
import { OutputEmitter } from '~@angular/compiler/src/output/abstract_emitter';
import { StyleCompiler } from '~@angular/compiler/src/style_compiler';
import { SummaryResolver } from '~@angular/compiler/src/summary_resolver';
import { TemplateParser } from '~@angular/compiler/src/template_parser/template_parser';
import { ViewCompiler } from '~@angular/compiler/src/view_compiler/view_compiler';
import { AotCompilerHost } from '~@angular/compiler/src/aot/compiler_host';
import { GeneratedFile } from '~@angular/compiler/src/aot/generated_file';
import { StaticSymbol } from '~@angular/compiler/src/aot/static_symbol';
import { StaticSymbolResolver } from '~@angular/compiler/src/aot/static_symbol_resolver';
export class AotCompiler {
    private _host;
    private _metadataResolver;
    private _templateParser;
    private _styleCompiler;
    private _viewCompiler;
    private _dirWrapperCompiler;
    private _ngModuleCompiler;
    private _outputEmitter;
    private _summaryResolver;
    private _localeId;
    private _translationFormat;
    private _animationParser;
    private _symbolResolver;
    private _animationCompiler;
    constructor(_host: AotCompilerHost, _metadataResolver: CompileMetadataResolver, _templateParser: TemplateParser, _styleCompiler: StyleCompiler, _viewCompiler: ViewCompiler, _dirWrapperCompiler: DirectiveWrapperCompiler, _ngModuleCompiler: NgModuleCompiler, _outputEmitter: OutputEmitter, _summaryResolver: SummaryResolver<StaticSymbol>, _localeId: string, _translationFormat: string, _animationParser: AnimationParser, _symbolResolver: StaticSymbolResolver);
    clearCache(): void;
    compileAll(rootFiles: string[]): Promise<GeneratedFile[]>;
    private _compileSrcFile(srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables);
    private _createSummary(srcFileUrl, directives, pipes, ngModules, injectables);
    private _compileModule(ngModuleType, targetStatements);
    private _compileDirectiveWrapper(directiveType, targetStatements);
    private _compileComponentFactory(compMeta, ngModule, fileSuffix, targetStatements);
    private _compileComponent(compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix, targetStatements);
    private _codgenStyles(fileUrl, stylesCompileResult, fileSuffix);
    private _codegenSourceModule(srcFileUrl, genFileUrl, statements, exportedVars);
}
export interface NgAnalyzedModules {
    ngModules: CompileNgModuleMetadata[];
    ngModuleByPipeOrDirective: Map<StaticSymbol, CompileNgModuleMetadata>;
    files: Array<{
        srcUrl: string;
        directives: StaticSymbol[];
        pipes: StaticSymbol[];
        ngModules: StaticSymbol[];
        injectables: StaticSymbol[];
    }>;
    symbolsMissingModule?: StaticSymbol[];
}
export interface NgAnalyzeModulesHost {
    isSourceFile(filePath: string): boolean;
}
export function analyzeNgModules(programStaticSymbols: StaticSymbol[], host: NgAnalyzeModulesHost, metadataResolver: CompileMetadataResolver): NgAnalyzedModules;
export function analyzeAndValidateNgModules(programStaticSymbols: StaticSymbol[], host: NgAnalyzeModulesHost, metadataResolver: CompileMetadataResolver): NgAnalyzedModules;
export function extractProgramSymbols(staticSymbolResolver: StaticSymbolResolver, files: string[], host: NgAnalyzeModulesHost): StaticSymbol[];
}
declare module '@angular/compiler/src/aot/compiler' {
export * from '~@angular/compiler/src/aot/compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/summary_serializer.d.ts
declare module '~@angular/compiler/src/aot/summary_serializer' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CompileTypeSummary } from '~@angular/compiler/src/compile_metadata';
import { Summary, SummaryResolver } from '~@angular/compiler/src/summary_resolver';
import { StaticSymbol, StaticSymbolCache } from '~@angular/compiler/src/aot/static_symbol';
import { ResolvedStaticSymbol, StaticSymbolResolver } from '~@angular/compiler/src/aot/static_symbol_resolver';
export interface AotSummarySerializerHost {
    /**
     * Returns the output file path of a source file.
     * E.g.
     * `some_file.ts` -> `some_file.d.ts`
     */
    getOutputFileName(sourceFilePath: string): string;
    /**
     * Returns whether a file is a source file or not.
     */
    isSourceFile(sourceFilePath: string): boolean;
}
export function serializeSummaries(host: AotSummarySerializerHost, summaryResolver: SummaryResolver<StaticSymbol>, symbolResolver: StaticSymbolResolver, symbols: ResolvedStaticSymbol[], types: CompileTypeSummary[]): string;
export function deserializeSummaries(symbolCache: StaticSymbolCache, json: string): Summary<StaticSymbol>[];
export function summaryFileName(fileName: string): string;
}
declare module '@angular/compiler/src/aot/summary_serializer' {
export * from '~@angular/compiler/src/aot/summary_serializer';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/compiler_host.d.ts
declare module '~@angular/compiler/src/aot/compiler_host' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ImportResolver } from '~@angular/compiler/src/output/path_util';
import { StaticSymbolResolverHost } from '~@angular/compiler/src/aot/static_symbol_resolver';
import { AotSummaryResolverHost } from '~@angular/compiler/src/aot/summary_resolver';
import { AotSummarySerializerHost } from '~@angular/compiler/src/aot/summary_serializer';
/**
 * The host of the AotCompiler disconnects the implementation from TypeScript / other language
 * services and from underlying file systems.
 */
export interface AotCompilerHost extends StaticSymbolResolverHost, ImportResolver, AotSummaryResolverHost, AotSummarySerializerHost {
    /**
     * Loads a resource (e.g. html / css)
     */
    loadResource(path: string): Promise<string>;
}
}
declare module '@angular/compiler/src/aot/compiler_host' {
export * from '~@angular/compiler/src/aot/compiler_host';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/static_reflector.d.ts
declare module '~@angular/compiler/src/aot/static_reflector' {
import { ReflectorReader } from '~@angular/compiler/src/private_import_core';
import { StaticSymbol } from '~@angular/compiler/src/aot/static_symbol';
import { StaticSymbolResolver } from '~@angular/compiler/src/aot/static_symbol_resolver';
/**
 * A static reflector implements enough of the Reflector API that is necessary to compile
 * templates statically.
 */
export class StaticReflector implements ReflectorReader {
    private symbolResolver;
    private errorRecorder;
    private annotationCache;
    private propertyCache;
    private parameterCache;
    private methodCache;
    private conversionMap;
    private opaqueToken;
    constructor(symbolResolver: StaticSymbolResolver, knownMetadataClasses?: {
        name: string;
        filePath: string;
        ctor: any;
    }[], knownMetadataFunctions?: {
        name: string;
        filePath: string;
        fn: any;
    }[], errorRecorder?: (error: any, fileName: string) => void);
    importUri(typeOrFunc: StaticSymbol): string;
    resolveIdentifier(name: string, moduleUrl: string): StaticSymbol;
    findDeclaration(moduleUrl: string, name: string, containingFile?: string): StaticSymbol;
    findSymbolDeclaration(symbol: StaticSymbol): StaticSymbol;
    resolveEnum(enumIdentifier: any, name: string): any;
    annotations(type: StaticSymbol): any[];
    propMetadata(type: StaticSymbol): {
        [key: string]: any[];
    };
    parameters(type: StaticSymbol): any[];
    private _methodNames(type);
    hasLifecycleHook(type: any, lcProperty: string): boolean;
    private _registerDecoratorOrConstructor(type, ctor);
    private _registerFunction(type, fn);
    private initializeConversionMap();
    /**
     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.
     * All types passed to the StaticResolver should be pseudo-types returned by this method.
     *
     * @param declarationFile the absolute path of the file where the symbol is declared
     * @param name the name of the type.
     */
    getStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol;
    private reportError(error, context, path?);
    private getTypeMetadata(type);
}
}
declare module '@angular/compiler/src/aot/static_reflector' {
export * from '~@angular/compiler/src/aot/static_reflector';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/static_reflection_capabilities.d.ts
declare module '~@angular/compiler/src/aot/static_reflection_capabilities' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { GetterFn, MethodFn, SetterFn } from '~@angular/compiler/src/private_import_core';
import { StaticReflector } from '~@angular/compiler/src/aot/static_reflector';
import { StaticSymbol } from '~@angular/compiler/src/aot/static_symbol';
export class StaticAndDynamicReflectionCapabilities {
    private staticDelegate;
    static install(staticDelegate: StaticReflector): void;
    private dynamicDelegate;
    constructor(staticDelegate: StaticReflector);
    isReflectionEnabled(): boolean;
    factory(type: any): Function;
    hasLifecycleHook(type: any, lcProperty: string): boolean;
    parameters(type: any): any[][];
    annotations(type: any): any[];
    propMetadata(typeOrFunc: any): {
        [key: string]: any[];
    };
    getter(name: string): GetterFn;
    setter(name: string): SetterFn;
    method(name: string): MethodFn;
    importUri(type: any): string;
    resolveIdentifier(name: string, moduleUrl: string, runtime: any): StaticSymbol;
    resolveEnum(enumIdentifier: any, name: string): any;
}
}
declare module '@angular/compiler/src/aot/static_reflection_capabilities' {
export * from '~@angular/compiler/src/aot/static_reflection_capabilities';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/static_symbol.d.ts
declare module '~@angular/compiler/src/aot/static_symbol' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A token representing the a reference to a static type.
 *
 * This token is unique for a filePath and name and can be used as a hash table key.
 */
export class StaticSymbol {
    filePath: string;
    name: string;
    members: string[];
    constructor(filePath: string, name: string, members?: string[]);
}
/**
 * A cache of static symbol used by the StaticReflector to return the same symbol for the
 * same symbol values.
 */
export class StaticSymbolCache {
    private cache;
    get(declarationFile: string, name: string, members?: string[]): StaticSymbol;
}
}
declare module '@angular/compiler/src/aot/static_symbol' {
export * from '~@angular/compiler/src/aot/static_symbol';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/static_symbol_resolver.d.ts
declare module '~@angular/compiler/src/aot/static_symbol_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SummaryResolver } from '~@angular/compiler/src/summary_resolver';
import { StaticSymbol, StaticSymbolCache } from '~@angular/compiler/src/aot/static_symbol';
export class ResolvedStaticSymbol {
    symbol: StaticSymbol;
    metadata: any;
    constructor(symbol: StaticSymbol, metadata: any);
}
/**
 * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other
 * language
 * services and from underlying file systems.
 */
export interface StaticSymbolResolverHost {
    /**
     * Return a ModuleMetadata for the given module.
     * Angular 2 CLI will produce this metadata for a module whenever a .d.ts files is
     * produced and the module has exported variables or classes with decorators. Module metadata can
     * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.
     *
     * @param modulePath is a string identifier for a module as an absolute path.
     * @returns the metadata for the given module.
     */
    getMetadataFor(modulePath: string): {
        [key: string]: any;
    }[];
    /**
     * Converts a module name that is used in an `import` to a file path.
     * I.e.
     * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.
     */
    moduleNameToFileName(moduleName: string, containingFile: string): string;
}
/**
 * This class is responsible for loading metadata per symbol,
 * and normalizing references between symbols.
 */
export class StaticSymbolResolver {
    private host;
    private staticSymbolCache;
    private summaryResolver;
    private errorRecorder;
    private metadataCache;
    private resolvedSymbols;
    private resolvedFilePaths;
    constructor(host: StaticSymbolResolverHost, staticSymbolCache: StaticSymbolCache, summaryResolver: SummaryResolver<StaticSymbol>, errorRecorder?: (error: any, fileName: string) => void);
    resolveSymbol(staticSymbol: StaticSymbol): ResolvedStaticSymbol;
    private _resolveSymbolMembers(staticSymbol);
    private _resolveSymbolFromSummary(staticSymbol);
    /**
     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.
     * All types passed to the StaticResolver should be pseudo-types returned by this method.
     *
     * @param declarationFile the absolute path of the file where the symbol is declared
     * @param name the name of the type.
     */
    getStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol;
    getSymbolsOf(filePath: string): StaticSymbol[];
    private _createSymbolsOf(filePath);
    private createResolvedSymbol(sourceSymbol, metadata);
    private reportError(error, context, path?);
    /**
     * @param module an absolute path to a module file.
     */
    private getModuleMetadata(module);
    getSymbolByModule(module: string, symbolName: string, containingFile?: string): StaticSymbol;
    private resolveModule(module, containingFile);
}
}
declare module '@angular/compiler/src/aot/static_symbol_resolver' {
export * from '~@angular/compiler/src/aot/static_symbol_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/aot/summary_resolver.d.ts
declare module '~@angular/compiler/src/aot/summary_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Summary, SummaryResolver } from '~@angular/compiler/src/summary_resolver';
import { StaticSymbol, StaticSymbolCache } from '~@angular/compiler/src/aot/static_symbol';
export interface AotSummaryResolverHost {
    /**
     * Loads an NgModule/Directive/Pipe summary file
     */
    loadSummary(filePath: string): string;
    /**
     * Returns whether a file is a source file or not.
     */
    isSourceFile(sourceFilePath: string): boolean;
}
export class AotSummaryResolver implements SummaryResolver<StaticSymbol> {
    private host;
    private staticSymbolCache;
    private summaryCache;
    private loadedFilePaths;
    constructor(host: AotSummaryResolverHost, staticSymbolCache: StaticSymbolCache);
    private _assertNoMembers(symbol);
    resolveSummary(staticSymbol: StaticSymbol): Summary<StaticSymbol>;
    getSymbolsOf(filePath: string): StaticSymbol[];
    private _loadSummaryFile(filePath);
}
}
declare module '@angular/compiler/src/aot/summary_resolver' {
export * from '~@angular/compiler/src/aot/summary_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/summary_resolver.d.ts
declare module '~@angular/compiler/src/summary_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CompileTypeSummary } from '~@angular/compiler/src/compile_metadata';
export interface Summary<T> {
    symbol: T;
    metadata: any;
    type?: CompileTypeSummary;
}
export class SummaryResolver<T> {
    resolveSummary(reference: T): Summary<T>;
    getSymbolsOf(filePath: string): T[];
}
}
declare module '@angular/compiler/src/summary_resolver' {
export * from '~@angular/compiler/src/summary_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/jit/compiler.d.ts
declare module '~@angular/compiler/src/jit/compiler' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Compiler, Injector, ModuleWithComponentFactories, NgModuleFactory, Type } from '@angular/core';
import { AnimationParser } from '~@angular/compiler/src/animation/animation_parser';
import { CompilerConfig } from '~@angular/compiler/src/config';
import { DirectiveWrapperCompiler } from '~@angular/compiler/src/directive_wrapper_compiler';
import { CompileMetadataResolver } from '~@angular/compiler/src/metadata_resolver';
import { NgModuleCompiler } from '~@angular/compiler/src/ng_module_compiler';
import { StyleCompiler } from '~@angular/compiler/src/style_compiler';
import { TemplateParser } from '~@angular/compiler/src/template_parser/template_parser';
import { ViewCompiler } from '~@angular/compiler/src/view_compiler/view_compiler';
/**
 * An internal module of the Angular compiler that begins with component types,
 * extracts templates, and eventually produces a compiled version of the component
 * ready for linking into an application.
 *
 * @security  When compiling templates at runtime, you must ensure that the entire template comes
 * from a trusted source. Attacker-controlled data introduced by a template could expose your
 * application to XSS risks.  For more detail, see the [Security Guide](http://g.co/ng/security).
 */
export class JitCompiler implements Compiler {
    private _injector;
    private _metadataResolver;
    private _templateParser;
    private _styleCompiler;
    private _viewCompiler;
    private _ngModuleCompiler;
    private _directiveWrapperCompiler;
    private _compilerConfig;
    private _animationParser;
    private _compiledTemplateCache;
    private _compiledHostTemplateCache;
    private _compiledDirectiveWrapperCache;
    private _compiledNgModuleCache;
    private _animationCompiler;
    constructor(_injector: Injector, _metadataResolver: CompileMetadataResolver, _templateParser: TemplateParser, _styleCompiler: StyleCompiler, _viewCompiler: ViewCompiler, _ngModuleCompiler: NgModuleCompiler, _directiveWrapperCompiler: DirectiveWrapperCompiler, _compilerConfig: CompilerConfig, _animationParser: AnimationParser);
    injector: Injector;
    compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T>;
    compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>>;
    compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T>;
    compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>): Promise<ModuleWithComponentFactories<T>>;
    getNgContentSelectors(component: Type<any>): string[];
    private _compileModuleAndComponents<T>(moduleType, isSync);
    private _compileModuleAndAllComponents<T>(moduleType, isSync);
    private _loadModules(mainModule, isSync);
    private _compileModule<T>(moduleType);
    clearCacheFor(type: Type<any>): void;
    clearCache(): void;
    private _createCompiledHostTemplate(compType, ngModule);
    private _createCompiledTemplate(compMeta, ngModule);
    private _assertComponentKnown(compType, isHost);
    private _assertDirectiveWrapper(dirType);
    private _compileDirectiveWrapper(dirMeta, moduleMeta);
    private _compileTemplate(template);
    private _resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);
    private _resolveAndEvalStylesCompileResult(result, externalStylesheetsByModuleUrl);
}
}
declare module '@angular/compiler/src/jit/compiler' {
export * from '~@angular/compiler/src/jit/compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/jit/compiler_factory.d.ts
declare module '~@angular/compiler/src/jit/compiler_factory' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Compiler, CompilerFactory, CompilerOptions, PlatformRef, Provider, Type } from '@angular/core';
/**
 * A set of providers that provide `JitCompiler` and its dependencies to use for
 * template compilation.
 */
export const COMPILER_PROVIDERS: Array<any | Type<any> | {
    [k: string]: any;
} | any[]>;
export class JitCompilerFactory implements CompilerFactory {
    private _defaultOptions;
    constructor(defaultOptions: CompilerOptions[]);
    createCompiler(options?: CompilerOptions[]): Compiler;
}
/**
 * A platform that included corePlatform and the compiler.
 *
 * @experimental
 */
export const platformCoreDynamic: (extraProviders?: Provider[]) => PlatformRef;
}
declare module '@angular/compiler/src/jit/compiler_factory' {
export * from '~@angular/compiler/src/jit/compiler_factory';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/url_resolver.d.ts
declare module '~@angular/compiler/src/url_resolver' {
/**
 * Create a {@link UrlResolver} with no package prefix.
 */
export function createUrlResolverWithoutPackagePrefix(): UrlResolver;
export function createOfflineCompileUrlResolver(): UrlResolver;
/**
 * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.
 */
export const DEFAULT_PACKAGE_URL_PROVIDER: {
    provide: any;
    useValue: string;
};
/**
 * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
 *
 * This class can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 *
 * ## Example
 *
 * {@example compiler/ts/url_resolver/url_resolver.ts region='url_resolver'}
 *
 * @security  When compiling templates at runtime, you must
 * ensure that the entire template comes from a trusted source.
 * Attacker-controlled data introduced by a template could expose your
 * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
 */
export class UrlResolver {
    private _packagePrefix;
    constructor(_packagePrefix?: string);
    /**
     * Resolves the `url` given the `baseUrl`:
     * - when the `url` is null, the `baseUrl` is returned,
     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
     * `baseUrl` and `url`,
     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
     * returned as is (ignoring the `baseUrl`)
     */
    resolve(baseUrl: string, url: string): string;
}
/**
 * Extract the scheme of a URL.
 */
export function getUrlScheme(url: string): string;
}
declare module '@angular/compiler/src/url_resolver' {
export * from '~@angular/compiler/src/url_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/resource_loader.d.ts
declare module '~@angular/compiler/src/resource_loader' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An interface for retrieving documents by URL that the compiler uses
 * to load templates.
 */
export class ResourceLoader {
    get(url: string): Promise<string>;
}
}
declare module '@angular/compiler/src/resource_loader' {
export * from '~@angular/compiler/src/resource_loader';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/directive_resolver.d.ts
declare module '~@angular/compiler/src/directive_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Directive, Type } from '@angular/core';
import { ReflectorReader } from '~@angular/compiler/src/private_import_core';
export class DirectiveResolver {
    private _reflector;
    constructor(_reflector?: ReflectorReader);
    isDirective(type: Type<any>): boolean;
    /**
     * Return {@link Directive} for a given `Type`.
     */
    resolve(type: Type<any>, throwIfNotFound?: boolean): Directive;
    private _mergeWithPropertyMetadata(dm, propertyMetadata, directiveType);
    private _extractPublicName(def);
    private _dedupeBindings(bindings);
    private _merge(directive, inputs, outputs, host, queries, directiveType);
}
}
declare module '@angular/compiler/src/directive_resolver' {
export * from '~@angular/compiler/src/directive_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/pipe_resolver.d.ts
declare module '~@angular/compiler/src/pipe_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Pipe, Type } from '@angular/core';
import { ReflectorReader } from '~@angular/compiler/src/private_import_core';
/**
 * Resolve a `Type` for {@link Pipe}.
 *
 * This interface can be overridden by the application developer to create custom behavior.
 *
 * See {@link Compiler}
 */
export class PipeResolver {
    private _reflector;
    constructor(_reflector?: ReflectorReader);
    isPipe(type: Type<any>): boolean;
    /**
     * Return {@link Pipe} for a given `Type`.
     */
    resolve(type: Type<any>, throwIfNotFound?: boolean): Pipe;
}
}
declare module '@angular/compiler/src/pipe_resolver' {
export * from '~@angular/compiler/src/pipe_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ng_module_resolver.d.ts
declare module '~@angular/compiler/src/ng_module_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { NgModule, Type } from '@angular/core';
import { ReflectorReader } from '~@angular/compiler/src/private_import_core';
/**
 * Resolves types to {@link NgModule}.
 */
export class NgModuleResolver {
    private _reflector;
    constructor(_reflector?: ReflectorReader);
    isNgModule(type: any): boolean;
    resolve(type: Type<any>, throwIfNotFound?: boolean): NgModule;
}
}
declare module '@angular/compiler/src/ng_module_resolver' {
export * from '~@angular/compiler/src/ng_module_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/interpolation_config.d.ts
declare module '~@angular/compiler/src/ml_parser/interpolation_config' {
export class InterpolationConfig {
    start: string;
    end: string;
    static fromArray(markers: [string, string]): InterpolationConfig;
    constructor(start: string, end: string);
}
export const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig;
}
declare module '@angular/compiler/src/ml_parser/interpolation_config' {
export * from '~@angular/compiler/src/ml_parser/interpolation_config';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/schema/element_schema_registry.d.ts
declare module '~@angular/compiler/src/schema/element_schema_registry' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SchemaMetadata, SecurityContext } from '@angular/core';
export abstract class ElementSchemaRegistry {
    abstract hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean;
    abstract hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean;
    abstract securityContext(elementName: string, propName: string, isAttribute: boolean): SecurityContext;
    abstract allKnownElementNames(): string[];
    abstract getMappedPropName(propName: string): string;
    abstract getDefaultComponentElementName(): string;
    abstract validateProperty(name: string): {
        error: boolean;
        msg?: string;
    };
    abstract validateAttribute(name: string): {
        error: boolean;
        msg?: string;
    };
    abstract normalizeAnimationStyleProperty(propName: string): string;
    abstract normalizeAnimationStyleValue(camelCaseProp: string, userProvidedProp: string, val: string | number): {
        error: string;
        value: string;
    };
}
}
declare module '@angular/compiler/src/schema/element_schema_registry' {
export * from '~@angular/compiler/src/schema/element_schema_registry';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/extractor.d.ts
declare module '~@angular/compiler/src/i18n/extractor' {
import { StaticReflector } from '~@angular/compiler/src/aot/static_reflector';
import { StaticSymbolResolver, StaticSymbolResolverHost } from '~@angular/compiler/src/aot/static_symbol_resolver';
import { AotSummaryResolverHost } from '~@angular/compiler/src/aot/summary_resolver';
import { CompileMetadataResolver } from '~@angular/compiler/src/metadata_resolver';
import { MessageBundle } from '~@angular/compiler/src/i18n/message_bundle';
/**
 * The host of the Extractor disconnects the implementation from TypeScript / other language
 * services and from underlying file systems.
 */
export interface ExtractorHost extends StaticSymbolResolverHost, AotSummaryResolverHost {
    /**
     * Loads a resource (e.g. html / css)
     */
    loadResource(path: string): Promise<string>;
}
export class Extractor {
    host: ExtractorHost;
    private staticSymbolResolver;
    private messageBundle;
    private metadataResolver;
    constructor(host: ExtractorHost, staticSymbolResolver: StaticSymbolResolver, messageBundle: MessageBundle, metadataResolver: CompileMetadataResolver);
    extract(rootFiles: string[]): Promise<MessageBundle>;
    static create(host: ExtractorHost): {
        extractor: Extractor;
        staticReflector: StaticReflector;
    };
}
}
declare module '@angular/compiler/src/i18n/extractor' {
export * from '~@angular/compiler/src/i18n/extractor';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/message_bundle.d.ts
declare module '~@angular/compiler/src/i18n/message_bundle' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HtmlParser } from '~@angular/compiler/src/ml_parser/html_parser';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { ParseError } from '~@angular/compiler/src/parse_util';
import { Message } from '~@angular/compiler/src/i18n/i18n_ast';
import { Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
/**
 * A container for message extracted from the templates.
 */
export class MessageBundle {
    private _htmlParser;
    private _implicitTags;
    private _implicitAttrs;
    private _messages;
    constructor(_htmlParser: HtmlParser, _implicitTags: string[], _implicitAttrs: {
        [k: string]: string[];
    });
    updateFromTemplate(html: string, url: string, interpolationConfig: InterpolationConfig): ParseError[];
    getMessages(): Message[];
    write(serializer: Serializer): string;
}
}
declare module '@angular/compiler/src/i18n/message_bundle' {
export * from '~@angular/compiler/src/i18n/message_bundle';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/i18n_ast.d.ts
declare module '~@angular/compiler/src/i18n/i18n_ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ParseSourceSpan } from '~@angular/compiler/src/parse_util';
export class Message {
    nodes: Node[];
    placeholders: {
        [phName: string]: string;
    };
    placeholderToMessage: {
        [phName: string]: Message;
    };
    meaning: string;
    description: string;
    /**
     * @param nodes message AST
     * @param placeholders maps placeholder names to static content
     * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)
     * @param meaning
     * @param description
     */
    constructor(nodes: Node[], placeholders: {
        [phName: string]: string;
    }, placeholderToMessage: {
        [phName: string]: Message;
    }, meaning: string, description: string);
}
export interface Node {
    sourceSpan: ParseSourceSpan;
    visit(visitor: Visitor, context?: any): any;
}
export class Text implements Node {
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class Container implements Node {
    children: Node[];
    sourceSpan: ParseSourceSpan;
    constructor(children: Node[], sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class Icu implements Node {
    expression: string;
    type: string;
    cases: {
        [k: string]: Node;
    };
    sourceSpan: ParseSourceSpan;
    expressionPlaceholder: string;
    constructor(expression: string, type: string, cases: {
        [k: string]: Node;
    }, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class TagPlaceholder implements Node {
    tag: string;
    attrs: {
        [k: string]: string;
    };
    startName: string;
    closeName: string;
    children: Node[];
    isVoid: boolean;
    sourceSpan: ParseSourceSpan;
    constructor(tag: string, attrs: {
        [k: string]: string;
    }, startName: string, closeName: string, children: Node[], isVoid: boolean, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class Placeholder implements Node {
    value: string;
    name: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, name: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export class IcuPlaceholder implements Node {
    value: Icu;
    name: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: Icu, name: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context?: any): any;
}
export interface Visitor {
    visitText(text: Text, context?: any): any;
    visitContainer(container: Container, context?: any): any;
    visitIcu(icu: Icu, context?: any): any;
    visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;
    visitPlaceholder(ph: Placeholder, context?: any): any;
    visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;
}
}
declare module '@angular/compiler/src/i18n/i18n_ast' {
export * from '~@angular/compiler/src/i18n/i18n_ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/serializers/serializer.d.ts
declare module '~@angular/compiler/src/i18n/serializers/serializer' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
export abstract class Serializer {
    abstract write(messages: i18n.Message[]): string;
    abstract load(content: string, url: string): {
        [msgId: string]: i18n.Node[];
    };
    abstract digest(message: i18n.Message): string;
    createNameMapper(message: i18n.Message): PlaceholderMapper;
}
/**
 * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and
 * back.
 *
 * It should be used for serialization format that put constraints on the placeholder names.
 */
export interface PlaceholderMapper {
    toPublicName(internalName: string): string;
    toInternalName(publicName: string): string;
}
}
declare module '@angular/compiler/src/i18n/serializers/serializer' {
export * from '~@angular/compiler/src/i18n/serializers/serializer';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/serializers/xliff.d.ts
declare module '~@angular/compiler/src/i18n/serializers/xliff' {
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
import { Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
export class Xliff extends Serializer {
    write(messages: i18n.Message[]): string;
    load(content: string, url: string): {
        [msgId: string]: i18n.Node[];
    };
    digest(message: i18n.Message): string;
}
}
declare module '@angular/compiler/src/i18n/serializers/xliff' {
export * from '~@angular/compiler/src/i18n/serializers/xliff';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/serializers/xmb.d.ts
declare module '~@angular/compiler/src/i18n/serializers/xmb' {
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
import { PlaceholderMapper, Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
export class Xmb extends Serializer {
    write(messages: i18n.Message[]): string;
    load(content: string, url: string): {
        [msgId: string]: i18n.Node[];
    };
    digest(message: i18n.Message): string;
    createNameMapper(message: i18n.Message): PlaceholderMapper;
}
export function digest(message: i18n.Message): string;
/**
 * XMB/XTB placeholders can only contain A-Z, 0-9 and _
 *
 * Because such restrictions do not exist on placeholder names generated locally, the
 * `PlaceholderMapper` is used to convert internal names to XMB names when the XMB file is
 * serialized and back from XTB to internal names when an XTB is loaded.
 */
export class XmbPlaceholderMapper implements PlaceholderMapper, i18n.Visitor {
    private internalToXmb;
    private xmbToNextId;
    private xmbToInternal;
    constructor(message: i18n.Message);
    toPublicName(internalName: string): string;
    toInternalName(publicName: string): string;
    visitText(text: i18n.Text, ctx?: any): any;
    visitContainer(container: i18n.Container, ctx?: any): any;
    visitIcu(icu: i18n.Icu, ctx?: any): any;
    visitTagPlaceholder(ph: i18n.TagPlaceholder, ctx?: any): any;
    visitPlaceholder(ph: i18n.Placeholder, ctx?: any): any;
    visitIcuPlaceholder(ph: i18n.IcuPlaceholder, ctx?: any): any;
    private addPlaceholder(internalName);
}
}
declare module '@angular/compiler/src/i18n/serializers/xmb' {
export * from '~@angular/compiler/src/i18n/serializers/xmb';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/serializers/xtb.d.ts
declare module '~@angular/compiler/src/i18n/serializers/xtb' {
import * as i18n from '~@angular/compiler/src/i18n/i18n_ast';
import { PlaceholderMapper, Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
export class Xtb extends Serializer {
    write(messages: i18n.Message[]): string;
    load(content: string, url: string): {
        [msgId: string]: i18n.Node[];
    };
    digest(message: i18n.Message): string;
    createNameMapper(message: i18n.Message): PlaceholderMapper;
}
}
declare module '@angular/compiler/src/i18n/serializers/xtb' {
export * from '~@angular/compiler/src/i18n/serializers/xtb';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/i18n/index.d.ts
declare module '~@angular/compiler/src/i18n/index' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { Extractor, ExtractorHost } from '~@angular/compiler/src/i18n/extractor';
export { I18NHtmlParser } from '~@angular/compiler/src/i18n/i18n_html_parser';
export { MessageBundle } from '~@angular/compiler/src/i18n/message_bundle';
export { Serializer } from '~@angular/compiler/src/i18n/serializers/serializer';
export { Xliff } from '~@angular/compiler/src/i18n/serializers/xliff';
export { Xmb } from '~@angular/compiler/src/i18n/serializers/xmb';
export { Xtb } from '~@angular/compiler/src/i18n/serializers/xtb';
}
declare module '@angular/compiler/src/i18n/index' {
export * from '~@angular/compiler/src/i18n/index';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/directive_normalizer.d.ts
declare module '~@angular/compiler/src/directive_normalizer' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ViewEncapsulation } from '@angular/core';
import { CompileAnimationEntryMetadata, CompileDirectiveMetadata, CompileStylesheetMetadata, CompileTemplateMetadata } from '~@angular/compiler/src/compile_metadata';
import { CompilerConfig } from '~@angular/compiler/src/config';
import { HtmlParser } from '~@angular/compiler/src/ml_parser/html_parser';
import { ResourceLoader } from '~@angular/compiler/src/resource_loader';
import { UrlResolver } from '~@angular/compiler/src/url_resolver';
import { SyncAsyncResult } from '~@angular/compiler/src/util';
export interface PrenormalizedTemplateMetadata {
    componentType: any;
    moduleUrl: string;
    template?: string;
    templateUrl?: string;
    styles?: string[];
    styleUrls?: string[];
    interpolation?: [string, string];
    encapsulation?: ViewEncapsulation;
    animations?: CompileAnimationEntryMetadata[];
}
export class DirectiveNormalizer {
    private _resourceLoader;
    private _urlResolver;
    private _htmlParser;
    private _config;
    private _resourceLoaderCache;
    constructor(_resourceLoader: ResourceLoader, _urlResolver: UrlResolver, _htmlParser: HtmlParser, _config: CompilerConfig);
    clearCache(): void;
    clearCacheFor(normalizedDirective: CompileDirectiveMetadata): void;
    private _fetch(url);
    normalizeTemplate(prenormData: PrenormalizedTemplateMetadata): SyncAsyncResult<CompileTemplateMetadata>;
    normalizeTemplateSync(prenomData: PrenormalizedTemplateMetadata): CompileTemplateMetadata;
    normalizeTemplateAsync(prenomData: PrenormalizedTemplateMetadata): Promise<CompileTemplateMetadata>;
    normalizeLoadedTemplate(prenomData: PrenormalizedTemplateMetadata, template: string, templateAbsUrl: string): CompileTemplateMetadata;
    normalizeExternalStylesheets(templateMeta: CompileTemplateMetadata): Promise<CompileTemplateMetadata>;
    private _loadMissingExternalStylesheets(styleUrls, loadedStylesheets?);
    normalizeStylesheet(stylesheet: CompileStylesheetMetadata): CompileStylesheetMetadata;
}
}
declare module '@angular/compiler/src/directive_normalizer' {
export * from '~@angular/compiler/src/directive_normalizer';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/expression_parser/lexer.d.ts
declare module '~@angular/compiler/src/expression_parser/lexer' {
export enum TokenType {
    Character = 0,
    Identifier = 1,
    Keyword = 2,
    String = 3,
    Operator = 4,
    Number = 5,
    Error = 6,
}
export class Lexer {
    tokenize(text: string): Token[];
}
export class Token {
    index: number;
    type: TokenType;
    numValue: number;
    strValue: string;
    constructor(index: number, type: TokenType, numValue: number, strValue: string);
    isCharacter(code: number): boolean;
    isNumber(): boolean;
    isString(): boolean;
    isOperator(operater: string): boolean;
    isIdentifier(): boolean;
    isKeyword(): boolean;
    isKeywordLet(): boolean;
    isKeywordNull(): boolean;
    isKeywordUndefined(): boolean;
    isKeywordTrue(): boolean;
    isKeywordFalse(): boolean;
    isKeywordThis(): boolean;
    isError(): boolean;
    toNumber(): number;
    toString(): string;
}
export const EOF: Token;
export function isIdentifier(input: string): boolean;
export function isQuote(code: number): boolean;
}
declare module '@angular/compiler/src/expression_parser/lexer' {
export * from '~@angular/compiler/src/expression_parser/lexer';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/expression_parser/parser.d.ts
declare module '~@angular/compiler/src/expression_parser/parser' {
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { AST, ASTWithSource, BindingPipe, LiteralMap, ParseSpan, ParserError, TemplateBinding } from '~@angular/compiler/src/expression_parser/ast';
import { Lexer, Token } from '~@angular/compiler/src/expression_parser/lexer';
export class SplitInterpolation {
    strings: string[];
    expressions: string[];
    offsets: number[];
    constructor(strings: string[], expressions: string[], offsets: number[]);
}
export class TemplateBindingParseResult {
    templateBindings: TemplateBinding[];
    warnings: string[];
    errors: ParserError[];
    constructor(templateBindings: TemplateBinding[], warnings: string[], errors: ParserError[]);
}
export class Parser {
    private _lexer;
    private errors;
    constructor(_lexer: Lexer);
    parseAction(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource;
    parseBinding(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource;
    parseSimpleBinding(input: string, location: string, interpolationConfig?: InterpolationConfig): ASTWithSource;
    private _reportError(message, input, errLocation, ctxLocation?);
    private _parseBindingAst(input, location, interpolationConfig);
    private _parseQuote(input, location);
    parseTemplateBindings(prefixToken: string, input: string, location: any): TemplateBindingParseResult;
    parseInterpolation(input: string, location: any, interpolationConfig?: InterpolationConfig): ASTWithSource;
    splitInterpolation(input: string, location: string, interpolationConfig?: InterpolationConfig): SplitInterpolation;
    wrapLiteralPrimitive(input: string, location: any): ASTWithSource;
    private _stripComments(input);
    private _commentStart(input);
    private _checkNoInterpolation(input, location, interpolationConfig);
    private _findInterpolationErrorColumn(parts, partInErrIdx, interpolationConfig);
}
export class _ParseAST {
    input: string;
    location: any;
    tokens: Token[];
    inputLength: number;
    parseAction: boolean;
    private errors;
    private offset;
    private rparensExpected;
    private rbracketsExpected;
    private rbracesExpected;
    index: number;
    constructor(input: string, location: any, tokens: Token[], inputLength: number, parseAction: boolean, errors: ParserError[], offset: number);
    peek(offset: number): Token;
    next: Token;
    inputIndex: number;
    span(start: number): ParseSpan;
    advance(): void;
    optionalCharacter(code: number): boolean;
    peekKeywordLet(): boolean;
    expectCharacter(code: number): void;
    optionalOperator(op: string): boolean;
    expectOperator(operator: string): void;
    expectIdentifierOrKeyword(): string;
    expectIdentifierOrKeywordOrString(): string;
    parseChain(): AST;
    parsePipe(): AST;
    parseExpression(): AST;
    parseConditional(): AST;
    parseLogicalOr(): AST;
    parseLogicalAnd(): AST;
    parseEquality(): AST;
    parseRelational(): AST;
    parseAdditive(): AST;
    parseMultiplicative(): AST;
    parsePrefix(): AST;
    parseCallChain(): AST;
    parsePrimary(): AST;
    parseExpressionList(terminator: number): AST[];
    parseLiteralMap(): LiteralMap;
    parseAccessMemberOrMethodCall(receiver: AST, isSafe?: boolean): AST;
    parseCallArguments(): BindingPipe[];
    /**
     * An identifier, a keyword, a string with an optional `-` inbetween.
     */
    expectTemplateBindingKey(): string;
    parseTemplateBindings(): TemplateBindingParseResult;
    error(message: string, index?: number): void;
    private locationText(index?);
    private skip();
}
}
declare module '@angular/compiler/src/expression_parser/parser' {
export * from '~@angular/compiler/src/expression_parser/parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/metadata_resolver.d.ts
declare module '~@angular/compiler/src/metadata_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AnimationEntryMetadata, Component, Directive, OpaqueToken, Type } from '@angular/core';
import * as cpl from '~@angular/compiler/src/compile_metadata';
import { DirectiveNormalizer } from '~@angular/compiler/src/directive_normalizer';
import { DirectiveResolver } from '~@angular/compiler/src/directive_resolver';
import { NgModuleResolver } from '~@angular/compiler/src/ng_module_resolver';
import { PipeResolver } from '~@angular/compiler/src/pipe_resolver';
import { ReflectorReader } from '~@angular/compiler/src/private_import_core';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
import { SummaryResolver } from '~@angular/compiler/src/summary_resolver';
export type ErrorCollector = (error: any, type?: any) => void;
export const ERROR_COLLECTOR_TOKEN: OpaqueToken;
export class CompileMetadataResolver {
    private _ngModuleResolver;
    private _directiveResolver;
    private _pipeResolver;
    private _summaryResolver;
    private _schemaRegistry;
    private _directiveNormalizer;
    private _reflector;
    private _errorCollector;
    private _directiveCache;
    private _summaryCache;
    private _pipeCache;
    private _ngModuleCache;
    private _ngModuleOfTypes;
    constructor(_ngModuleResolver: NgModuleResolver, _directiveResolver: DirectiveResolver, _pipeResolver: PipeResolver, _summaryResolver: SummaryResolver<any>, _schemaRegistry: ElementSchemaRegistry, _directiveNormalizer: DirectiveNormalizer, _reflector?: ReflectorReader, _errorCollector?: ErrorCollector);
    clearCacheFor(type: Type<any>): void;
    clearCache(): void;
    getAnimationEntryMetadata(entry: AnimationEntryMetadata): cpl.CompileAnimationEntryMetadata;
    private _getAnimationStateMetadata(value);
    private _getAnimationStyleMetadata(value);
    private _getAnimationMetadata(value);
    private _loadSummary(type, kind);
    private _loadDirectiveMetadata(directiveType, isSync);
    getNonNormalizedDirectiveMetadata(directiveType: any): {
        annotation: Directive;
        metadata: cpl.CompileDirectiveMetadata;
    };
    /**
     * Gets the metadata for the given directive.
     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.
     */
    getDirectiveMetadata(directiveType: any): cpl.CompileDirectiveMetadata;
    getDirectiveSummary(dirType: any): cpl.CompileDirectiveSummary;
    isDirective(type: any): boolean;
    isPipe(type: any): boolean;
    getNgModuleSummary(moduleType: any): cpl.CompileNgModuleSummary;
    /**
     * Loads the declared directives and pipes of an NgModule.
     */
    loadNgModuleDirectiveAndPipeMetadata(moduleType: any, isSync: boolean, throwIfNotFound?: boolean): Promise<any>;
    getNgModuleMetadata(moduleType: any, throwIfNotFound?: boolean): cpl.CompileNgModuleMetadata;
    private _getTypeDescriptor(type);
    private _addTypeToModule(type, moduleType);
    private _getTransitiveNgModuleMetadata(importedModules, exportedModules);
    private _getIdentifierMetadata(type);
    isInjectable(type: any): boolean;
    getInjectableSummary(type: any): cpl.CompileTypeSummary;
    private _getInjectableMetadata(type, dependencies?);
    private _getTypeMetadata(type, dependencies?);
    private _getFactoryMetadata(factory, dependencies?);
    /**
     * Gets the metadata for the given pipe.
     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.
     */
    getPipeMetadata(pipeType: any): cpl.CompilePipeMetadata;
    getPipeSummary(pipeType: any): cpl.CompilePipeSummary;
    getOrLoadPipeMetadata(pipeType: any): cpl.CompilePipeMetadata;
    private _loadPipeMetadata(pipeType);
    private _getDependenciesMetadata(typeOrFunc, dependencies);
    private _getTokenMetadata(token);
    private _getProvidersMetadata(providers, targetEntryComponents, debugInfo?, compileProviders?, type?);
    private _getEntryComponentsFromProvider(provider, type?);
    getProviderMetadata(provider: cpl.ProviderMeta): cpl.CompileProviderMetadata;
    private _getQueriesMetadata(queries, isViewQuery, directiveType);
    private _queryVarBindings(selector);
    private _getQueryMetadata(q, propertyName, typeOrFunc);
    private _reportError(error, type?, otherType?);
}
export function componentModuleUrl(reflector: ReflectorReader, type: Type<any>, cmpMetadata: Component): string;
}
declare module '@angular/compiler/src/metadata_resolver' {
export * from '~@angular/compiler/src/metadata_resolver';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/ast.d.ts
declare module '~@angular/compiler/src/ml_parser/ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ParseSourceSpan } from '~@angular/compiler/src/parse_util';
export interface Node {
    sourceSpan: ParseSourceSpan;
    visit(visitor: Visitor, context: any): any;
}
export class Text implements Node {
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class Expansion implements Node {
    switchValue: string;
    type: string;
    cases: ExpansionCase[];
    sourceSpan: ParseSourceSpan;
    switchValueSourceSpan: ParseSourceSpan;
    constructor(switchValue: string, type: string, cases: ExpansionCase[], sourceSpan: ParseSourceSpan, switchValueSourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class ExpansionCase implements Node {
    value: string;
    expression: Node[];
    sourceSpan: ParseSourceSpan;
    valueSourceSpan: ParseSourceSpan;
    expSourceSpan: ParseSourceSpan;
    constructor(value: string, expression: Node[], sourceSpan: ParseSourceSpan, valueSourceSpan: ParseSourceSpan, expSourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class Attribute implements Node {
    name: string;
    value: string;
    sourceSpan: ParseSourceSpan;
    valueSpan: ParseSourceSpan;
    constructor(name: string, value: string, sourceSpan: ParseSourceSpan, valueSpan?: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class Element implements Node {
    name: string;
    attrs: Attribute[];
    children: Node[];
    sourceSpan: ParseSourceSpan;
    startSourceSpan: ParseSourceSpan;
    endSourceSpan: ParseSourceSpan;
    constructor(name: string, attrs: Attribute[], children: Node[], sourceSpan: ParseSourceSpan, startSourceSpan: ParseSourceSpan, endSourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export class Comment implements Node {
    value: string;
    sourceSpan: ParseSourceSpan;
    constructor(value: string, sourceSpan: ParseSourceSpan);
    visit(visitor: Visitor, context: any): any;
}
export interface Visitor {
    visit?(node: Node, context: any): any;
    visitElement(element: Element, context: any): any;
    visitAttribute(attribute: Attribute, context: any): any;
    visitText(text: Text, context: any): any;
    visitComment(comment: Comment, context: any): any;
    visitExpansion(expansion: Expansion, context: any): any;
    visitExpansionCase(expansionCase: ExpansionCase, context: any): any;
}
export function visitAll(visitor: Visitor, nodes: Node[], context?: any): any[];
}
declare module '@angular/compiler/src/ml_parser/ast' {
export * from '~@angular/compiler/src/ml_parser/ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/tags.d.ts
declare module '~@angular/compiler/src/ml_parser/tags' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export enum TagContentType {
    RAW_TEXT = 0,
    ESCAPABLE_RAW_TEXT = 1,
    PARSABLE_DATA = 2,
}
export interface TagDefinition {
    closedByParent: boolean;
    requiredParents: {
        [key: string]: boolean;
    };
    parentToAdd: string;
    implicitNamespacePrefix: string;
    contentType: TagContentType;
    isVoid: boolean;
    ignoreFirstLf: boolean;
    canSelfClose: boolean;
    requireExtraParent(currentParent: string): boolean;
    isClosedByChild(name: string): boolean;
}
export function splitNsName(elementName: string): [string, string];
export function getNsPrefix(fullName: string): string;
export function mergeNsAndName(prefix: string, localName: string): string;
export const NAMED_ENTITIES: {
    [k: string]: string;
};
}
declare module '@angular/compiler/src/ml_parser/tags' {
export * from '~@angular/compiler/src/ml_parser/tags';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/parser.d.ts
declare module '~@angular/compiler/src/ml_parser/parser' {
import { ParseError, ParseSourceSpan } from '~@angular/compiler/src/parse_util';
import * as html from '~@angular/compiler/src/ml_parser/ast';
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { TagDefinition } from '~@angular/compiler/src/ml_parser/tags';
export class TreeError extends ParseError {
    elementName: string;
    static create(elementName: string, span: ParseSourceSpan, msg: string): TreeError;
    constructor(elementName: string, span: ParseSourceSpan, msg: string);
}
export class ParseTreeResult {
    rootNodes: html.Node[];
    errors: ParseError[];
    constructor(rootNodes: html.Node[], errors: ParseError[]);
}
export class Parser {
    getTagDefinition: (tagName: string) => TagDefinition;
    constructor(getTagDefinition: (tagName: string) => TagDefinition);
    parse(source: string, url: string, parseExpansionForms?: boolean, interpolationConfig?: InterpolationConfig): ParseTreeResult;
}
}
declare module '@angular/compiler/src/ml_parser/parser' {
export * from '~@angular/compiler/src/ml_parser/parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ml_parser/html_parser.d.ts
declare module '~@angular/compiler/src/ml_parser/html_parser' {
import { InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
import { ParseTreeResult, Parser } from '~@angular/compiler/src/ml_parser/parser';
export { ParseTreeResult, TreeError } from '~@angular/compiler/src/ml_parser/parser';
export class HtmlParser extends Parser {
    constructor();
    parse(source: string, url: string, parseExpansionForms?: boolean, interpolationConfig?: InterpolationConfig): ParseTreeResult;
}
}
declare module '@angular/compiler/src/ml_parser/html_parser' {
export * from '~@angular/compiler/src/ml_parser/html_parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/output/output_ast.d.ts
declare module '~@angular/compiler/src/output/output_ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CompileIdentifierMetadata } from '~@angular/compiler/src/compile_metadata';
export enum TypeModifier {
    Const = 0,
}
export abstract class Type {
    modifiers: TypeModifier[];
    constructor(modifiers?: TypeModifier[]);
    abstract visitType(visitor: TypeVisitor, context: any): any;
    hasModifier(modifier: TypeModifier): boolean;
}
export enum BuiltinTypeName {
    Dynamic = 0,
    Bool = 1,
    String = 2,
    Int = 3,
    Number = 4,
    Function = 5,
    Null = 6,
}
export class BuiltinType extends Type {
    name: BuiltinTypeName;
    constructor(name: BuiltinTypeName, modifiers?: TypeModifier[]);
    visitType(visitor: TypeVisitor, context: any): any;
}
export class ExpressionType extends Type {
    value: Expression;
    typeParams: Type[];
    constructor(value: Expression, typeParams?: Type[], modifiers?: TypeModifier[]);
    visitType(visitor: TypeVisitor, context: any): any;
}
export class ArrayType extends Type {
    of: Type;
    constructor(of: Type, modifiers?: TypeModifier[]);
    visitType(visitor: TypeVisitor, context: any): any;
}
export class MapType extends Type {
    valueType: Type;
    constructor(valueType: Type, modifiers?: TypeModifier[]);
    visitType(visitor: TypeVisitor, context: any): any;
}
export const DYNAMIC_TYPE: BuiltinType;
export const BOOL_TYPE: BuiltinType;
export const INT_TYPE: BuiltinType;
export const NUMBER_TYPE: BuiltinType;
export const STRING_TYPE: BuiltinType;
export const FUNCTION_TYPE: BuiltinType;
export const NULL_TYPE: BuiltinType;
export interface TypeVisitor {
    visitBuiltintType(type: BuiltinType, context: any): any;
    visitExpressionType(type: ExpressionType, context: any): any;
    visitArrayType(type: ArrayType, context: any): any;
    visitMapType(type: MapType, context: any): any;
}
export enum BinaryOperator {
    Equals = 0,
    NotEquals = 1,
    Identical = 2,
    NotIdentical = 3,
    Minus = 4,
    Plus = 5,
    Divide = 6,
    Multiply = 7,
    Modulo = 8,
    And = 9,
    Or = 10,
    Lower = 11,
    LowerEquals = 12,
    Bigger = 13,
    BiggerEquals = 14,
}
export abstract class Expression {
    type: Type;
    constructor(type: Type);
    abstract visitExpression(visitor: ExpressionVisitor, context: any): any;
    prop(name: string): ReadPropExpr;
    key(index: Expression, type?: Type): ReadKeyExpr;
    callMethod(name: string | BuiltinMethod, params: Expression[]): InvokeMethodExpr;
    callFn(params: Expression[]): InvokeFunctionExpr;
    instantiate(params: Expression[], type?: Type): InstantiateExpr;
    conditional(trueCase: Expression, falseCase?: Expression): ConditionalExpr;
    equals(rhs: Expression): BinaryOperatorExpr;
    notEquals(rhs: Expression): BinaryOperatorExpr;
    identical(rhs: Expression): BinaryOperatorExpr;
    notIdentical(rhs: Expression): BinaryOperatorExpr;
    minus(rhs: Expression): BinaryOperatorExpr;
    plus(rhs: Expression): BinaryOperatorExpr;
    divide(rhs: Expression): BinaryOperatorExpr;
    multiply(rhs: Expression): BinaryOperatorExpr;
    modulo(rhs: Expression): BinaryOperatorExpr;
    and(rhs: Expression): BinaryOperatorExpr;
    or(rhs: Expression): BinaryOperatorExpr;
    lower(rhs: Expression): BinaryOperatorExpr;
    lowerEquals(rhs: Expression): BinaryOperatorExpr;
    bigger(rhs: Expression): BinaryOperatorExpr;
    biggerEquals(rhs: Expression): BinaryOperatorExpr;
    isBlank(): Expression;
    cast(type: Type): Expression;
    toStmt(): Statement;
}
export enum BuiltinVar {
    This = 0,
    Super = 1,
    CatchError = 2,
    CatchStack = 3,
}
export class ReadVarExpr extends Expression {
    name: string;
    builtin: BuiltinVar;
    constructor(name: string | BuiltinVar, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    set(value: Expression): WriteVarExpr;
}
export class WriteVarExpr extends Expression {
    name: string;
    value: Expression;
    constructor(name: string, value: Expression, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    toDeclStmt(type?: Type, modifiers?: StmtModifier[]): DeclareVarStmt;
}
export class WriteKeyExpr extends Expression {
    receiver: Expression;
    index: Expression;
    value: Expression;
    constructor(receiver: Expression, index: Expression, value: Expression, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class WritePropExpr extends Expression {
    receiver: Expression;
    name: string;
    value: Expression;
    constructor(receiver: Expression, name: string, value: Expression, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export enum BuiltinMethod {
    ConcatArray = 0,
    SubscribeObservable = 1,
    Bind = 2,
}
export class InvokeMethodExpr extends Expression {
    receiver: Expression;
    args: Expression[];
    name: string;
    builtin: BuiltinMethod;
    constructor(receiver: Expression, method: string | BuiltinMethod, args: Expression[], type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class InvokeFunctionExpr extends Expression {
    fn: Expression;
    args: Expression[];
    constructor(fn: Expression, args: Expression[], type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class InstantiateExpr extends Expression {
    classExpr: Expression;
    args: Expression[];
    constructor(classExpr: Expression, args: Expression[], type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class LiteralExpr extends Expression {
    value: any;
    constructor(value: any, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class ExternalExpr extends Expression {
    value: CompileIdentifierMetadata;
    typeParams: Type[];
    constructor(value: CompileIdentifierMetadata, type?: Type, typeParams?: Type[]);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class ConditionalExpr extends Expression {
    condition: Expression;
    falseCase: Expression;
    trueCase: Expression;
    constructor(condition: Expression, trueCase: Expression, falseCase?: Expression, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class NotExpr extends Expression {
    condition: Expression;
    constructor(condition: Expression);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class CastExpr extends Expression {
    value: Expression;
    constructor(value: Expression, type: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class FnParam {
    name: string;
    type: Type;
    constructor(name: string, type?: Type);
}
export class FunctionExpr extends Expression {
    params: FnParam[];
    statements: Statement[];
    constructor(params: FnParam[], statements: Statement[], type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    toDeclStmt(name: string, modifiers?: StmtModifier[]): DeclareFunctionStmt;
}
export class BinaryOperatorExpr extends Expression {
    operator: BinaryOperator;
    rhs: Expression;
    lhs: Expression;
    constructor(operator: BinaryOperator, lhs: Expression, rhs: Expression, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class ReadPropExpr extends Expression {
    receiver: Expression;
    name: string;
    constructor(receiver: Expression, name: string, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    set(value: Expression): WritePropExpr;
}
export class ReadKeyExpr extends Expression {
    receiver: Expression;
    index: Expression;
    constructor(receiver: Expression, index: Expression, type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
    set(value: Expression): WriteKeyExpr;
}
export class LiteralArrayExpr extends Expression {
    entries: Expression[];
    constructor(entries: Expression[], type?: Type);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export class LiteralMapEntry {
    key: string;
    value: Expression;
    quoted: boolean;
    constructor(key: string, value: Expression, quoted?: boolean);
}
export class LiteralMapExpr extends Expression {
    entries: LiteralMapEntry[];
    valueType: Type;
    constructor(entries: LiteralMapEntry[], type?: MapType);
    visitExpression(visitor: ExpressionVisitor, context: any): any;
}
export interface ExpressionVisitor {
    visitReadVarExpr(ast: ReadVarExpr, context: any): any;
    visitWriteVarExpr(expr: WriteVarExpr, context: any): any;
    visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;
    visitWritePropExpr(expr: WritePropExpr, context: any): any;
    visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;
    visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;
    visitInstantiateExpr(ast: InstantiateExpr, context: any): any;
    visitLiteralExpr(ast: LiteralExpr, context: any): any;
    visitExternalExpr(ast: ExternalExpr, context: any): any;
    visitConditionalExpr(ast: ConditionalExpr, context: any): any;
    visitNotExpr(ast: NotExpr, context: any): any;
    visitCastExpr(ast: CastExpr, context: any): any;
    visitFunctionExpr(ast: FunctionExpr, context: any): any;
    visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;
    visitReadPropExpr(ast: ReadPropExpr, context: any): any;
    visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;
    visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;
    visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;
}
export const THIS_EXPR: ReadVarExpr;
export const SUPER_EXPR: ReadVarExpr;
export const CATCH_ERROR_VAR: ReadVarExpr;
export const CATCH_STACK_VAR: ReadVarExpr;
export const NULL_EXPR: LiteralExpr;
export const TYPED_NULL_EXPR: LiteralExpr;
export enum StmtModifier {
    Final = 0,
    Private = 1,
}
export abstract class Statement {
    modifiers: StmtModifier[];
    constructor(modifiers?: StmtModifier[]);
    abstract visitStatement(visitor: StatementVisitor, context: any): any;
    hasModifier(modifier: StmtModifier): boolean;
}
export class DeclareVarStmt extends Statement {
    name: string;
    value: Expression;
    type: Type;
    constructor(name: string, value: Expression, type?: Type, modifiers?: StmtModifier[]);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class DeclareFunctionStmt extends Statement {
    name: string;
    params: FnParam[];
    statements: Statement[];
    type: Type;
    constructor(name: string, params: FnParam[], statements: Statement[], type?: Type, modifiers?: StmtModifier[]);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class ExpressionStatement extends Statement {
    expr: Expression;
    constructor(expr: Expression);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class ReturnStatement extends Statement {
    value: Expression;
    constructor(value: Expression);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class AbstractClassPart {
    type: Type;
    modifiers: StmtModifier[];
    constructor(type: Type, modifiers: StmtModifier[]);
    hasModifier(modifier: StmtModifier): boolean;
}
export class ClassField extends AbstractClassPart {
    name: string;
    constructor(name: string, type?: Type, modifiers?: StmtModifier[]);
}
export class ClassMethod extends AbstractClassPart {
    name: string;
    params: FnParam[];
    body: Statement[];
    constructor(name: string, params: FnParam[], body: Statement[], type?: Type, modifiers?: StmtModifier[]);
}
export class ClassGetter extends AbstractClassPart {
    name: string;
    body: Statement[];
    constructor(name: string, body: Statement[], type?: Type, modifiers?: StmtModifier[]);
}
export class ClassStmt extends Statement {
    name: string;
    parent: Expression;
    fields: ClassField[];
    getters: ClassGetter[];
    constructorMethod: ClassMethod;
    methods: ClassMethod[];
    constructor(name: string, parent: Expression, fields: ClassField[], getters: ClassGetter[], constructorMethod: ClassMethod, methods: ClassMethod[], modifiers?: StmtModifier[]);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class IfStmt extends Statement {
    condition: Expression;
    trueCase: Statement[];
    falseCase: Statement[];
    constructor(condition: Expression, trueCase: Statement[], falseCase?: Statement[]);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class CommentStmt extends Statement {
    comment: string;
    constructor(comment: string);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class TryCatchStmt extends Statement {
    bodyStmts: Statement[];
    catchStmts: Statement[];
    constructor(bodyStmts: Statement[], catchStmts: Statement[]);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export class ThrowStmt extends Statement {
    error: Expression;
    constructor(error: Expression);
    visitStatement(visitor: StatementVisitor, context: any): any;
}
export interface StatementVisitor {
    visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;
    visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;
    visitExpressionStmt(stmt: ExpressionStatement, context: any): any;
    visitReturnStmt(stmt: ReturnStatement, context: any): any;
    visitDeclareClassStmt(stmt: ClassStmt, context: any): any;
    visitIfStmt(stmt: IfStmt, context: any): any;
    visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;
    visitThrowStmt(stmt: ThrowStmt, context: any): any;
    visitCommentStmt(stmt: CommentStmt, context: any): any;
}
export class ExpressionTransformer implements StatementVisitor, ExpressionVisitor {
    visitReadVarExpr(ast: ReadVarExpr, context: any): any;
    visitWriteVarExpr(expr: WriteVarExpr, context: any): any;
    visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;
    visitWritePropExpr(expr: WritePropExpr, context: any): any;
    visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;
    visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;
    visitInstantiateExpr(ast: InstantiateExpr, context: any): any;
    visitLiteralExpr(ast: LiteralExpr, context: any): any;
    visitExternalExpr(ast: ExternalExpr, context: any): any;
    visitConditionalExpr(ast: ConditionalExpr, context: any): any;
    visitNotExpr(ast: NotExpr, context: any): any;
    visitCastExpr(ast: CastExpr, context: any): any;
    visitFunctionExpr(ast: FunctionExpr, context: any): any;
    visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;
    visitReadPropExpr(ast: ReadPropExpr, context: any): any;
    visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;
    visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;
    visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;
    visitAllExpressions(exprs: Expression[], context: any): Expression[];
    visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;
    visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;
    visitExpressionStmt(stmt: ExpressionStatement, context: any): any;
    visitReturnStmt(stmt: ReturnStatement, context: any): any;
    visitDeclareClassStmt(stmt: ClassStmt, context: any): any;
    visitIfStmt(stmt: IfStmt, context: any): any;
    visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;
    visitThrowStmt(stmt: ThrowStmt, context: any): any;
    visitCommentStmt(stmt: CommentStmt, context: any): any;
    visitAllStatements(stmts: Statement[], context: any): Statement[];
}
export class RecursiveExpressionVisitor implements StatementVisitor, ExpressionVisitor {
    visitReadVarExpr(ast: ReadVarExpr, context: any): any;
    visitWriteVarExpr(expr: WriteVarExpr, context: any): any;
    visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;
    visitWritePropExpr(expr: WritePropExpr, context: any): any;
    visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;
    visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;
    visitInstantiateExpr(ast: InstantiateExpr, context: any): any;
    visitLiteralExpr(ast: LiteralExpr, context: any): any;
    visitExternalExpr(ast: ExternalExpr, context: any): any;
    visitConditionalExpr(ast: ConditionalExpr, context: any): any;
    visitNotExpr(ast: NotExpr, context: any): any;
    visitCastExpr(ast: CastExpr, context: any): any;
    visitFunctionExpr(ast: FunctionExpr, context: any): any;
    visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;
    visitReadPropExpr(ast: ReadPropExpr, context: any): any;
    visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;
    visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;
    visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;
    visitAllExpressions(exprs: Expression[], context: any): void;
    visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;
    visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;
    visitExpressionStmt(stmt: ExpressionStatement, context: any): any;
    visitReturnStmt(stmt: ReturnStatement, context: any): any;
    visitDeclareClassStmt(stmt: ClassStmt, context: any): any;
    visitIfStmt(stmt: IfStmt, context: any): any;
    visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;
    visitThrowStmt(stmt: ThrowStmt, context: any): any;
    visitCommentStmt(stmt: CommentStmt, context: any): any;
    visitAllStatements(stmts: Statement[], context: any): void;
}
export function replaceVarInExpression(varName: string, newValue: Expression, expression: Expression): Expression;
export function findReadVarNames(stmts: Statement[]): Set<string>;
export function variable(name: string, type?: Type): ReadVarExpr;
export function importExpr(id: CompileIdentifierMetadata, typeParams?: Type[]): ExternalExpr;
export function importType(id: CompileIdentifierMetadata, typeParams?: Type[], typeModifiers?: TypeModifier[]): ExpressionType;
export function expressionType(expr: Expression, typeParams?: Type[], typeModifiers?: TypeModifier[]): ExpressionType;
export function literalArr(values: Expression[], type?: Type): LiteralArrayExpr;
export function literalMap(values: [string, Expression][], type?: MapType, quoted?: boolean): LiteralMapExpr;
export function not(expr: Expression): NotExpr;
export function fn(params: FnParam[], body: Statement[], type?: Type): FunctionExpr;
export function literal(value: any, type?: Type): LiteralExpr;
}
declare module '@angular/compiler/src/output/output_ast' {
export * from '~@angular/compiler/src/output/output_ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/ng_module_compiler.d.ts
declare module '~@angular/compiler/src/ng_module_compiler' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CompileIdentifierMetadata, CompileNgModuleMetadata, CompileProviderMetadata } from '~@angular/compiler/src/compile_metadata';
import * as o from '~@angular/compiler/src/output/output_ast';
export class ComponentFactoryDependency {
    comp: CompileIdentifierMetadata;
    placeholder: CompileIdentifierMetadata;
    constructor(comp: CompileIdentifierMetadata, placeholder: CompileIdentifierMetadata);
}
export class NgModuleCompileResult {
    statements: o.Statement[];
    ngModuleFactoryVar: string;
    dependencies: ComponentFactoryDependency[];
    constructor(statements: o.Statement[], ngModuleFactoryVar: string, dependencies: ComponentFactoryDependency[]);
}
export class NgModuleCompiler {
    compile(ngModuleMeta: CompileNgModuleMetadata, extraProviders: CompileProviderMetadata[]): NgModuleCompileResult;
}
}
declare module '@angular/compiler/src/ng_module_compiler' {
export * from '~@angular/compiler/src/ng_module_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/directive_wrapper_compiler.d.ts
declare module '~@angular/compiler/src/directive_wrapper_compiler' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CompileDirectiveMetadata, CompileDirectiveSummary, CompileIdentifierMetadata } from '~@angular/compiler/src/compile_metadata';
import { CompilerConfig } from '~@angular/compiler/src/config';
import { Parser } from '~@angular/compiler/src/expression_parser/parser';
import * as o from '~@angular/compiler/src/output/output_ast';
import { Console } from '~@angular/compiler/src/private_import_core';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
import { BoundElementPropertyAst, BoundEventAst } from '~@angular/compiler/src/template_parser/template_ast';
export class DirectiveWrapperCompileResult {
    statements: o.Statement[];
    dirWrapperClassVar: string;
    constructor(statements: o.Statement[], dirWrapperClassVar: string);
}
/**
 * We generate directive wrappers to prevent code bloat when a directive is used.
 * A directive wrapper encapsulates
 * the dirty checking for `@Input`, the handling of `@HostListener` / `@HostBinding`
 * and calling the lifecyclehooks `ngOnInit`, `ngOnChanges`, `ngDoCheck`.
 *
 * So far, only `@Input` and the lifecycle hooks have been implemented.
 */
export class DirectiveWrapperCompiler {
    private compilerConfig;
    private _exprParser;
    private _schemaRegistry;
    private _console;
    static dirWrapperClassName(id: CompileIdentifierMetadata): string;
    constructor(compilerConfig: CompilerConfig, _exprParser: Parser, _schemaRegistry: ElementSchemaRegistry, _console: Console);
    compile(dirMeta: CompileDirectiveMetadata): DirectiveWrapperCompileResult;
}
export class DirectiveWrapperExpressions {
    static create(dir: CompileIdentifierMetadata, depsExpr: o.Expression[]): o.Expression;
    static context(dirWrapper: o.Expression): o.ReadPropExpr;
    static ngDoCheck(dirWrapper: o.Expression, view: o.Expression, renderElement: o.Expression, throwOnChange: o.Expression): o.Expression;
    static checkHost(hostProps: BoundElementPropertyAst[], dirWrapper: o.Expression, view: o.Expression, componentView: o.Expression, renderElement: o.Expression, throwOnChange: o.Expression, runtimeSecurityContexts: o.Expression[]): o.Statement[];
    static ngOnDetach(hostProps: BoundElementPropertyAst[], dirWrapper: o.Expression, view: o.Expression, componentView: o.Expression, renderEl: o.Expression): o.Statement[];
    static ngOnDestroy(dir: CompileDirectiveSummary, dirWrapper: o.Expression): o.Statement[];
    static subscribe(dirMeta: CompileDirectiveSummary, hostProps: BoundElementPropertyAst[], usedEvents: string[], dirWrapper: o.Expression, view: o.Expression, eventListener: o.Expression): o.Statement[];
    static handleEvent(hostEvents: BoundEventAst[], dirWrapper: o.Expression, eventName: o.Expression, event: o.Expression): o.Expression;
}
}
declare module '@angular/compiler/src/directive_wrapper_compiler' {
export * from '~@angular/compiler/src/directive_wrapper_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/output/path_util.d.ts
declare module '~@angular/compiler/src/output/path_util' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Interface that defines how import statements should be generated.
 */
export abstract class ImportResolver {
    /**
     * Converts a file path to a module name that can be used as an `import.
     * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.
     */
    abstract fileNameToModuleName(importedFilePath: string, containingFilePath: string): string;
}
}
declare module '@angular/compiler/src/output/path_util' {
export * from '~@angular/compiler/src/output/path_util';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/output/ts_emitter.d.ts
declare module '~@angular/compiler/src/output/ts_emitter' {
import { OutputEmitter } from '~@angular/compiler/src/output/abstract_emitter';
import * as o from '~@angular/compiler/src/output/output_ast';
import { ImportResolver } from '~@angular/compiler/src/output/path_util';
export function debugOutputAstAsTypeScript(ast: o.Statement | o.Expression | o.Type | any[]): string;
export class TypeScriptEmitter implements OutputEmitter {
    private _importGenerator;
    constructor(_importGenerator: ImportResolver);
    emitStatements(moduleUrl: string, stmts: o.Statement[], exportedVars: string[]): string;
}
}
declare module '@angular/compiler/src/output/ts_emitter' {
export * from '~@angular/compiler/src/output/ts_emitter';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/parse_util.d.ts
declare module '~@angular/compiler/src/parse_util' {
export class ParseLocation {
    file: ParseSourceFile;
    offset: number;
    line: number;
    col: number;
    constructor(file: ParseSourceFile, offset: number, line: number, col: number);
    toString(): string;
    moveBy(delta: number): ParseLocation;
    getContext(maxChars: number, maxLines: number): {
        before: string;
        after: string;
    };
}
export class ParseSourceFile {
    content: string;
    url: string;
    constructor(content: string, url: string);
}
export class ParseSourceSpan {
    start: ParseLocation;
    end: ParseLocation;
    details: string;
    constructor(start: ParseLocation, end: ParseLocation, details?: string);
    toString(): string;
}
export enum ParseErrorLevel {
    WARNING = 0,
    FATAL = 1,
}
export class ParseError {
    span: ParseSourceSpan;
    msg: string;
    level: ParseErrorLevel;
    constructor(span: ParseSourceSpan, msg: string, level?: ParseErrorLevel);
    toString(): string;
}
}
declare module '@angular/compiler/src/parse_util' {
export * from '~@angular/compiler/src/parse_util';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/schema/dom_element_schema_registry.d.ts
declare module '~@angular/compiler/src/schema/dom_element_schema_registry' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SchemaMetadata, SecurityContext } from '@angular/core';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
export class DomElementSchemaRegistry extends ElementSchemaRegistry {
    private _schema;
    constructor();
    hasProperty(tagName: string, propName: string, schemaMetas: SchemaMetadata[]): boolean;
    hasElement(tagName: string, schemaMetas: SchemaMetadata[]): boolean;
    /**
     * securityContext returns the security context for the given property on the given DOM tag.
     *
     * Tag and property name are statically known and cannot change at runtime, i.e. it is not
     * possible to bind a value into a changing attribute or tag name.
     *
     * The filtering is white list based. All attributes in the schema above are assumed to have the
     * 'NONE' security context, i.e. that they are safe inert string values. Only specific well known
     * attack vectors are assigned their appropriate context.
     */
    securityContext(tagName: string, propName: string, isAttribute: boolean): SecurityContext;
    getMappedPropName(propName: string): string;
    getDefaultComponentElementName(): string;
    validateProperty(name: string): {
        error: boolean;
        msg?: string;
    };
    validateAttribute(name: string): {
        error: boolean;
        msg?: string;
    };
    allKnownElementNames(): string[];
    normalizeAnimationStyleProperty(propName: string): string;
    normalizeAnimationStyleValue(camelCaseProp: string, userProvidedProp: string, val: string | number): {
        error: string;
        value: string;
    };
}
}
declare module '@angular/compiler/src/schema/dom_element_schema_registry' {
export * from '~@angular/compiler/src/schema/dom_element_schema_registry';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/selector.d.ts
declare module '~@angular/compiler/src/selector' {
/**
 * A css selector contains an element name,
 * css classes and attribute/value pairs with the purpose
 * of selecting subsets out of them.
 */
export class CssSelector {
    element: string;
    classNames: string[];
    attrs: string[];
    notSelectors: CssSelector[];
    static parse(selector: string): CssSelector[];
    isElementSelector(): boolean;
    hasElementSelector(): boolean;
    setElement(element?: string): void;
    /** Gets a template string for an element that matches the selector. */
    getMatchingElementTemplate(): string;
    addAttribute(name: string, value?: string): void;
    addClassName(name: string): void;
    toString(): string;
}
/**
 * Reads a list of CssSelectors and allows to calculate which ones
 * are contained in a given CssSelector.
 */
export class SelectorMatcher {
    static createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher;
    private _elementMap;
    private _elementPartialMap;
    private _classMap;
    private _classPartialMap;
    private _attrValueMap;
    private _attrValuePartialMap;
    private _listContexts;
    addSelectables(cssSelectors: CssSelector[], callbackCtxt?: any): void;
    /**
     * Add an object that can be found later on by calling `match`.
     * @param cssSelector A css selector
     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
     */
    private _addSelectable(cssSelector, callbackCtxt, listContext);
    private _addTerminal(map, name, selectable);
    private _addPartial(map, name);
    /**
     * Find the objects that have been added via `addSelectable`
     * whose css selector is contained in the given css selector.
     * @param cssSelector A css selector
     * @param matchedCallback This callback will be called with the object handed into `addSelectable`
     * @return boolean true if a match was found
    */
    match(cssSelector: CssSelector, matchedCallback: (c: CssSelector, a: any) => void): boolean;
}
export class SelectorListContext {
    selectors: CssSelector[];
    alreadyMatched: boolean;
    constructor(selectors: CssSelector[]);
}
export class SelectorContext {
    selector: CssSelector;
    cbContext: any;
    listContext: SelectorListContext;
    notSelectors: CssSelector[];
    constructor(selector: CssSelector, cbContext: any, listContext: SelectorListContext);
    finalize(cssSelector: CssSelector, callback: (c: CssSelector, a: any) => void): boolean;
}
}
declare module '@angular/compiler/src/selector' {
export * from '~@angular/compiler/src/selector';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/style_compiler.d.ts
declare module '~@angular/compiler/src/style_compiler' {
import { CompileDirectiveMetadata, CompileIdentifierMetadata, CompileStylesheetMetadata } from '~@angular/compiler/src/compile_metadata';
import * as o from '~@angular/compiler/src/output/output_ast';
import { UrlResolver } from '~@angular/compiler/src/url_resolver';
export class StylesCompileDependency {
    name: string;
    moduleUrl: string;
    isShimmed: boolean;
    valuePlaceholder: CompileIdentifierMetadata;
    constructor(name: string, moduleUrl: string, isShimmed: boolean, valuePlaceholder: CompileIdentifierMetadata);
}
export class StylesCompileResult {
    componentStylesheet: CompiledStylesheet;
    externalStylesheets: CompiledStylesheet[];
    constructor(componentStylesheet: CompiledStylesheet, externalStylesheets: CompiledStylesheet[]);
}
export class CompiledStylesheet {
    statements: o.Statement[];
    stylesVar: string;
    dependencies: StylesCompileDependency[];
    isShimmed: boolean;
    meta: CompileStylesheetMetadata;
    constructor(statements: o.Statement[], stylesVar: string, dependencies: StylesCompileDependency[], isShimmed: boolean, meta: CompileStylesheetMetadata);
}
export class StyleCompiler {
    private _urlResolver;
    private _shadowCss;
    constructor(_urlResolver: UrlResolver);
    compileComponent(comp: CompileDirectiveMetadata): StylesCompileResult;
    private _compileStyles(comp, stylesheet, isComponentStylesheet);
    private _shimIfNeeded(style, shim);
}
}
declare module '@angular/compiler/src/style_compiler' {
export * from '~@angular/compiler/src/style_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/animation/animation_compiler.d.ts
declare module '~@angular/compiler/src/animation/animation_compiler' {
import * as o from '~@angular/compiler/src/output/output_ast';
import { AnimationEntryAst } from '~@angular/compiler/src/animation/animation_ast';
export class AnimationEntryCompileResult {
    name: string;
    statements: o.Statement[];
    fnExp: o.Expression;
    constructor(name: string, statements: o.Statement[], fnExp: o.Expression);
}
export class AnimationCompiler {
    compile(factoryNamePrefix: string, parsedAnimations: AnimationEntryAst[]): AnimationEntryCompileResult[];
}
}
declare module '@angular/compiler/src/animation/animation_compiler' {
export * from '~@angular/compiler/src/animation/animation_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/view_compiler/deps.d.ts
declare module '~@angular/compiler/src/view_compiler/deps' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CompileIdentifierMetadata } from '~@angular/compiler/src/compile_metadata';
export class ViewClassDependency {
    comp: CompileIdentifierMetadata;
    name: string;
    placeholder: CompileIdentifierMetadata;
    constructor(comp: CompileIdentifierMetadata, name: string, placeholder: CompileIdentifierMetadata);
}
export class ComponentFactoryDependency {
    comp: CompileIdentifierMetadata;
    placeholder: CompileIdentifierMetadata;
    constructor(comp: CompileIdentifierMetadata, placeholder: CompileIdentifierMetadata);
}
export class DirectiveWrapperDependency {
    dir: CompileIdentifierMetadata;
    name: string;
    placeholder: CompileIdentifierMetadata;
    constructor(dir: CompileIdentifierMetadata, name: string, placeholder: CompileIdentifierMetadata);
}
}
declare module '@angular/compiler/src/view_compiler/deps' {
export * from '~@angular/compiler/src/view_compiler/deps';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/view_compiler/view_compiler.d.ts
declare module '~@angular/compiler/src/view_compiler/view_compiler' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AnimationEntryCompileResult } from '~@angular/compiler/src/animation/animation_compiler';
import { CompileDirectiveMetadata, CompilePipeSummary } from '~@angular/compiler/src/compile_metadata';
import { CompilerConfig } from '~@angular/compiler/src/config';
import * as o from '~@angular/compiler/src/output/output_ast';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
import { TemplateAst } from '~@angular/compiler/src/template_parser/template_ast';
import { ComponentFactoryDependency, DirectiveWrapperDependency, ViewClassDependency } from '~@angular/compiler/src/view_compiler/deps';
export { ComponentFactoryDependency, DirectiveWrapperDependency, ViewClassDependency } from '~@angular/compiler/src/view_compiler/deps';
export class ViewCompileResult {
    statements: o.Statement[];
    viewClassVar: string;
    dependencies: Array<ViewClassDependency | ComponentFactoryDependency | DirectiveWrapperDependency>;
    constructor(statements: o.Statement[], viewClassVar: string, dependencies: Array<ViewClassDependency | ComponentFactoryDependency | DirectiveWrapperDependency>);
}
export class ViewCompiler {
    private _genConfig;
    private _schemaRegistry;
    constructor(_genConfig: CompilerConfig, _schemaRegistry: ElementSchemaRegistry);
    compileComponent(component: CompileDirectiveMetadata, template: TemplateAst[], styles: o.Expression, pipes: CompilePipeSummary[], compiledAnimations: AnimationEntryCompileResult[]): ViewCompileResult;
}
}
declare module '@angular/compiler/src/view_compiler/view_compiler' {
export * from '~@angular/compiler/src/view_compiler/view_compiler';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/animation/animation_ast.d.ts
declare module '~@angular/compiler/src/animation/animation_ast' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export abstract class AnimationAst {
    startTime: number;
    playTime: number;
    abstract visit(visitor: AnimationAstVisitor, context: any): any;
}
export abstract class AnimationStateAst extends AnimationAst {
    abstract visit(visitor: AnimationAstVisitor, context: any): any;
}
export interface AnimationAstVisitor {
    visitAnimationEntry(ast: AnimationEntryAst, context: any): any;
    visitAnimationStateDeclaration(ast: AnimationStateDeclarationAst, context: any): any;
    visitAnimationStateTransition(ast: AnimationStateTransitionAst, context: any): any;
    visitAnimationStep(ast: AnimationStepAst, context: any): any;
    visitAnimationSequence(ast: AnimationSequenceAst, context: any): any;
    visitAnimationGroup(ast: AnimationGroupAst, context: any): any;
    visitAnimationKeyframe(ast: AnimationKeyframeAst, context: any): any;
    visitAnimationStyles(ast: AnimationStylesAst, context: any): any;
}
export class AnimationEntryAst extends AnimationAst {
    name: string;
    stateDeclarations: AnimationStateDeclarationAst[];
    stateTransitions: AnimationStateTransitionAst[];
    constructor(name: string, stateDeclarations: AnimationStateDeclarationAst[], stateTransitions: AnimationStateTransitionAst[]);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export class AnimationStateDeclarationAst extends AnimationStateAst {
    stateName: string;
    styles: AnimationStylesAst;
    constructor(stateName: string, styles: AnimationStylesAst);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export class AnimationStateTransitionExpression {
    fromState: string;
    toState: string;
    constructor(fromState: string, toState: string);
}
export class AnimationStateTransitionAst extends AnimationStateAst {
    stateChanges: AnimationStateTransitionExpression[];
    animation: AnimationWithStepsAst;
    constructor(stateChanges: AnimationStateTransitionExpression[], animation: AnimationWithStepsAst);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export class AnimationStepAst extends AnimationAst {
    startingStyles: AnimationStylesAst;
    keyframes: AnimationKeyframeAst[];
    duration: number;
    delay: number;
    easing: string;
    constructor(startingStyles: AnimationStylesAst, keyframes: AnimationKeyframeAst[], duration: number, delay: number, easing: string);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export class AnimationStylesAst extends AnimationAst {
    styles: Array<{
        [key: string]: string | number;
    }>;
    constructor(styles: Array<{
        [key: string]: string | number;
    }>);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export class AnimationKeyframeAst extends AnimationAst {
    offset: number;
    styles: AnimationStylesAst;
    constructor(offset: number, styles: AnimationStylesAst);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export abstract class AnimationWithStepsAst extends AnimationAst {
    steps: AnimationAst[];
    constructor(steps: AnimationAst[]);
}
export class AnimationGroupAst extends AnimationWithStepsAst {
    constructor(steps: AnimationAst[]);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
export class AnimationSequenceAst extends AnimationWithStepsAst {
    constructor(steps: AnimationAst[]);
    visit(visitor: AnimationAstVisitor, context: any): any;
}
}
declare module '@angular/compiler/src/animation/animation_ast' {
export * from '~@angular/compiler/src/animation/animation_ast';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/animation/animation_parser.d.ts
declare module '~@angular/compiler/src/animation/animation_parser' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { CompileAnimationEntryMetadata, CompileDirectiveMetadata } from '~@angular/compiler/src/compile_metadata';
import { ParseError } from '~@angular/compiler/src/parse_util';
import { ElementSchemaRegistry } from '~@angular/compiler/src/schema/element_schema_registry';
import { AnimationEntryAst } from '~@angular/compiler/src/animation/animation_ast';
export class AnimationParseError extends ParseError {
    constructor(message: string);
    toString(): string;
}
export class AnimationEntryParseResult {
    ast: AnimationEntryAst;
    errors: AnimationParseError[];
    constructor(ast: AnimationEntryAst, errors: AnimationParseError[]);
}
export class AnimationParser {
    private _schema;
    constructor(_schema: ElementSchemaRegistry);
    parseComponent(component: CompileDirectiveMetadata): AnimationEntryAst[];
    parseEntry(entry: CompileAnimationEntryMetadata): AnimationEntryParseResult;
}
}
declare module '@angular/compiler/src/animation/animation_parser' {
export * from '~@angular/compiler/src/animation/animation_parser';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/facade/errors.d.ts
declare module '~@angular/compiler/src/facade/errors' {

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Convenience to throw an Error with 'unimplemented' as the message.
 */
export function unimplemented(): any;
/**
 * @stable
 */
export class BaseError extends Error {
    constructor(message: string);
    message: string;
    name: string;
    stack: any;
    toString(): string;
}
/**
 * @stable
 */
export class WrappedError extends BaseError {
    originalError: any;
    constructor(message: string, error: any);
    stack: any;
}
}
declare module '@angular/compiler/src/facade/errors' {
export * from '~@angular/compiler/src/facade/errors';
}

// Generated by typings
// Source: node_modules/@angular/compiler/src/util.d.ts
declare module '~@angular/compiler/src/util' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { BaseError } from '~@angular/compiler/src/facade/errors';
export const MODULE_SUFFIX: string;
export function camelCaseToDashCase(input: string): string;
export function dashCaseToCamelCase(input: string): string;
export function splitAtColon(input: string, defaultValues: string[]): string[];
export function splitAtPeriod(input: string, defaultValues: string[]): string[];
export function visitValue(value: any, visitor: ValueVisitor, context: any): any;
export interface ValueVisitor {
    visitArray(arr: any[], context: any): any;
    visitStringMap(map: {
        [key: string]: any;
    }, context: any): any;
    visitPrimitive(value: any, context: any): any;
    visitOther(value: any, context: any): any;
}
export class ValueTransformer implements ValueVisitor {
    visitArray(arr: any[], context: any): any;
    visitStringMap(map: {
        [key: string]: any;
    }, context: any): any;
    visitPrimitive(value: any, context: any): any;
    visitOther(value: any, context: any): any;
}
export class SyncAsyncResult<T> {
    syncResult: T;
    asyncResult: Promise<T>;
    constructor(syncResult: T, asyncResult?: Promise<T>);
}
export class SyntaxError extends BaseError {
}
}
declare module '@angular/compiler/src/util' {
export * from '~@angular/compiler/src/util';
}

// Generated by typings
// Source: node_modules/@angular/compiler/index.d.ts
declare module '~@angular/compiler/index' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all APIs of the compiler package.
 *
 * <div class="callout is-critical">
 *   <header>Unstable APIs</header>
 *   <p>
 *     All compiler apis are currently considered experimental and private!
 *   </p>
 *   <p>
 *     We expect the APIs in this package to keep on changing. Do not rely on them.
 *   </p>
 * </div>
 */
export { VERSION } from '~@angular/compiler/src/version';
export * from '~@angular/compiler/src/template_parser/template_ast';
export { TEMPLATE_TRANSFORMS } from '~@angular/compiler/src/template_parser/template_parser';
export { CompilerConfig, RenderTypes } from '~@angular/compiler/src/config';
export * from '~@angular/compiler/src/compile_metadata';
export * from '~@angular/compiler/src/aot/compiler_factory';
export * from '~@angular/compiler/src/aot/compiler';
export * from '~@angular/compiler/src/aot/compiler_host';
export * from '~@angular/compiler/src/aot/static_reflector';
export * from '~@angular/compiler/src/aot/static_reflection_capabilities';
export * from '~@angular/compiler/src/aot/static_symbol';
export * from '~@angular/compiler/src/aot/static_symbol_resolver';
export * from '~@angular/compiler/src/aot/summary_resolver';
export * from '~@angular/compiler/src/summary_resolver';
export { JitCompiler } from '~@angular/compiler/src/jit/compiler';
export * from '~@angular/compiler/src/jit/compiler_factory';
export * from '~@angular/compiler/src/url_resolver';
export * from '~@angular/compiler/src/resource_loader';
export { DirectiveResolver } from '~@angular/compiler/src/directive_resolver';
export { PipeResolver } from '~@angular/compiler/src/pipe_resolver';
export { NgModuleResolver } from '~@angular/compiler/src/ng_module_resolver';
export { DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig } from '~@angular/compiler/src/ml_parser/interpolation_config';
export * from '~@angular/compiler/src/schema/element_schema_registry';
export * from '~@angular/compiler/src/i18n/index';
export * from '~@angular/compiler/src/directive_normalizer';
export * from '~@angular/compiler/src/expression_parser/lexer';
export * from '~@angular/compiler/src/expression_parser/parser';
export * from '~@angular/compiler/src/metadata_resolver';
export * from '~@angular/compiler/src/ml_parser/html_parser';
export * from '~@angular/compiler/src/ml_parser/interpolation_config';
export { NgModuleCompiler } from '~@angular/compiler/src/ng_module_compiler';
export { DirectiveWrapperCompiler } from '~@angular/compiler/src/directive_wrapper_compiler';
export * from '~@angular/compiler/src/output/path_util';
export * from '~@angular/compiler/src/output/ts_emitter';
export * from '~@angular/compiler/src/parse_util';
export * from '~@angular/compiler/src/schema/dom_element_schema_registry';
export * from '~@angular/compiler/src/selector';
export * from '~@angular/compiler/src/style_compiler';
export * from '~@angular/compiler/src/template_parser/template_parser';
export { ViewCompiler } from '~@angular/compiler/src/view_compiler/view_compiler';
export { AnimationParser } from '~@angular/compiler/src/animation/animation_parser';
export { SyntaxError } from '~@angular/compiler/src/util';
}
declare module '@angular/compiler/index' {
export * from '~@angular/compiler/index';
}
declare module '@angular/compiler' {
export * from '~@angular/compiler/index';
}
